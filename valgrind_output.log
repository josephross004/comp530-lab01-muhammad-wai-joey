\n\n\n------------------------\n
Test case: tc1
\n------------------------\n\n\n
==708== Memcheck, a memory error detector
==708== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==708== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==708== Command: ./testcase tc1
==708== 
==708== 
==708== HEAP SUMMARY:
==708==     in use at exit: 0 bytes in 0 blocks
==708==   total heap usage: 7 allocs, 7 frees, 864 bytes allocated
==708== 
==708== All heap blocks were freed -- no leaks are possible
==708== 
==708== For lists of detected and suppressed errors, rerun with: -s
==708== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc2
\n------------------------\n\n\n
==711== Memcheck, a memory error detector
==711== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==711== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==711== Command: ./testcase tc2
==711== 
==711== 
==711== HEAP SUMMARY:
==711==     in use at exit: 0 bytes in 0 blocks
==711==   total heap usage: 9 allocs, 9 frees, 1,946 bytes allocated
==711== 
==711== All heap blocks were freed -- no leaks are possible
==711== 
==711== For lists of detected and suppressed errors, rerun with: -s
==711== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc3
\n------------------------\n\n\n
==714== Memcheck, a memory error detector
==714== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==714== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==714== Command: ./testcase tc3
==714== 
==714== Use of uninitialised value of size 8
==714==    at 0x10A325: create_request (server.c:419)
==714==    by 0x10AAA5: run_test (testcase.c:77)
==714==    by 0x10ACD1: get3 (testcase.c:138)
==714==    by 0x10B35C: main (testcase.c:334)
==714== 
==714== Invalid read of size 1
==714==    at 0x10A325: create_request (server.c:419)
==714==    by 0x10AAA5: run_test (testcase.c:77)
==714==    by 0x10ACD1: get3 (testcase.c:138)
==714==    by 0x10B35C: main (testcase.c:334)
==714==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==714== 
==714== 
==714== Process terminating with default action of signal 11 (SIGSEGV)
==714==  Access not within mapped region at address 0x0
==714==    at 0x10A325: create_request (server.c:419)
==714==    by 0x10AAA5: run_test (testcase.c:77)
==714==    by 0x10ACD1: get3 (testcase.c:138)
==714==    by 0x10B35C: main (testcase.c:334)
==714==  If you believe this happened as a result of a stack
==714==  overflow in your program's main thread (unlikely but
==714==  possible), you can try to increase the size of the
==714==  main thread stack using the --main-stacksize= flag.
==714==  The main thread stack size used in this run was 8388608.
==714== 
==714== HEAP SUMMARY:
==714==     in use at exit: 320 bytes in 5 blocks
==714==   total heap usage: 5 allocs, 0 frees, 320 bytes allocated
==714== 
==714== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==714==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==714==    by 0x109AFB: create_request (server.c:286)
==714==    by 0x10AAA5: run_test (testcase.c:77)
==714==    by 0x10ACD1: get3 (testcase.c:138)
==714==    by 0x10B35C: main (testcase.c:334)
==714== 
==714== 10 bytes in 1 blocks are still reachable in loss record 2 of 5
==714==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==714==    by 0x109DB1: create_request (server.c:342)
==714==    by 0x10AAA5: run_test (testcase.c:77)
==714==    by 0x10ACD1: get3 (testcase.c:138)
==714==    by 0x10B35C: main (testcase.c:334)
==714== 
==714== 10 bytes in 1 blocks are still reachable in loss record 3 of 5
==714==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==714==    by 0x109DEA: create_request (server.c:344)
==714==    by 0x10AAA5: run_test (testcase.c:77)
==714==    by 0x10ACD1: get3 (testcase.c:138)
==714==    by 0x10B35C: main (testcase.c:334)
==714== 
==714== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==714==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==714==    by 0x109A95: create_request (server.c:277)
==714==    by 0x10AAA5: run_test (testcase.c:77)
==714==    by 0x10ACD1: get3 (testcase.c:138)
==714==    by 0x10B35C: main (testcase.c:334)
==714== 
==714== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==714==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==714==    by 0x10AA7D: run_test (testcase.c:73)
==714==    by 0x10ACD1: get3 (testcase.c:138)
==714==    by 0x10B35C: main (testcase.c:334)
==714== 
==714== LEAK SUMMARY:
==714==    definitely lost: 0 bytes in 0 blocks
==714==    indirectly lost: 0 bytes in 0 blocks
==714==      possibly lost: 0 bytes in 0 blocks
==714==    still reachable: 320 bytes in 5 blocks
==714==         suppressed: 0 bytes in 0 blocks
==714== 
==714== Use --track-origins=yes to see where uninitialised values come from
==714== For lists of detected and suppressed errors, rerun with: -s
==714== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc4
\n------------------------\n\n\n
==717== Memcheck, a memory error detector
==717== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==717== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==717== Command: ./testcase tc4
==717== 
==717== 
==717== HEAP SUMMARY:
==717==     in use at exit: 0 bytes in 0 blocks
==717==   total heap usage: 7 allocs, 7 frees, 1,348 bytes allocated
==717== 
==717== All heap blocks were freed -- no leaks are possible
==717== 
==717== For lists of detected and suppressed errors, rerun with: -s
==717== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc5
\n------------------------\n\n\n
==720== Memcheck, a memory error detector
==720== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==720== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==720== Command: ./testcase tc5
==720== 
==720== Invalid read of size 1
==720==    at 0x109E3E: create_request (server.c:352)
==720==    by 0x10AAA5: run_test (testcase.c:77)
==720==    by 0x10AD6D: get5 (testcase.c:148)
==720==    by 0x10B35C: main (testcase.c:334)
==720==  Address 0x4a78140 is 0 bytes after a block of size 256 alloc'd
==720==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==720==    by 0x10AA7D: run_test (testcase.c:73)
==720==    by 0x10AD6D: get5 (testcase.c:148)
==720==    by 0x10B35C: main (testcase.c:334)
==720== 
==720== Conditional jump or move depends on uninitialised value(s)
==720==    at 0x109E43: create_request (server.c:352)
==720==    by 0x10AAA5: run_test (testcase.c:77)
==720==    by 0x10AD6D: get5 (testcase.c:148)
==720==    by 0x10B35C: main (testcase.c:334)
==720== 
==720== Use of uninitialised value of size 8
==720==    at 0x10A325: create_request (server.c:419)
==720==    by 0x10AAA5: run_test (testcase.c:77)
==720==    by 0x10AD6D: get5 (testcase.c:148)
==720==    by 0x10B35C: main (testcase.c:334)
==720== 
==720== Invalid read of size 1
==720==    at 0x10A325: create_request (server.c:419)
==720==    by 0x10AAA5: run_test (testcase.c:77)
==720==    by 0x10AD6D: get5 (testcase.c:148)
==720==    by 0x10B35C: main (testcase.c:334)
==720==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==720== 
==720== 
==720== Process terminating with default action of signal 11 (SIGSEGV)
==720==  Access not within mapped region at address 0x0
==720==    at 0x10A325: create_request (server.c:419)
==720==    by 0x10AAA5: run_test (testcase.c:77)
==720==    by 0x10AD6D: get5 (testcase.c:148)
==720==    by 0x10B35C: main (testcase.c:334)
==720==  If you believe this happened as a result of a stack
==720==  overflow in your program's main thread (unlikely but
==720==  possible), you can try to increase the size of the
==720==  main thread stack using the --main-stacksize= flag.
==720==  The main thread stack size used in this run was 8388608.
==720== 
==720== HEAP SUMMARY:
==720==     in use at exit: 326 bytes in 5 blocks
==720==   total heap usage: 5 allocs, 0 frees, 326 bytes allocated
==720== 
==720== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==720==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==720==    by 0x109AFB: create_request (server.c:286)
==720==    by 0x10AAA5: run_test (testcase.c:77)
==720==    by 0x10AD6D: get5 (testcase.c:148)
==720==    by 0x10B35C: main (testcase.c:334)
==720== 
==720== 13 bytes in 1 blocks are still reachable in loss record 2 of 5
==720==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==720==    by 0x109DB1: create_request (server.c:342)
==720==    by 0x10AAA5: run_test (testcase.c:77)
==720==    by 0x10AD6D: get5 (testcase.c:148)
==720==    by 0x10B35C: main (testcase.c:334)
==720== 
==720== 13 bytes in 1 blocks are still reachable in loss record 3 of 5
==720==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==720==    by 0x109DEA: create_request (server.c:344)
==720==    by 0x10AAA5: run_test (testcase.c:77)
==720==    by 0x10AD6D: get5 (testcase.c:148)
==720==    by 0x10B35C: main (testcase.c:334)
==720== 
==720== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==720==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==720==    by 0x109A95: create_request (server.c:277)
==720==    by 0x10AAA5: run_test (testcase.c:77)
==720==    by 0x10AD6D: get5 (testcase.c:148)
==720==    by 0x10B35C: main (testcase.c:334)
==720== 
==720== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==720==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==720==    by 0x10AA7D: run_test (testcase.c:73)
==720==    by 0x10AD6D: get5 (testcase.c:148)
==720==    by 0x10B35C: main (testcase.c:334)
==720== 
==720== LEAK SUMMARY:
==720==    definitely lost: 0 bytes in 0 blocks
==720==    indirectly lost: 0 bytes in 0 blocks
==720==      possibly lost: 0 bytes in 0 blocks
==720==    still reachable: 326 bytes in 5 blocks
==720==         suppressed: 0 bytes in 0 blocks
==720== 
==720== Use --track-origins=yes to see where uninitialised values come from
==720== For lists of detected and suppressed errors, rerun with: -s
==720== ERROR SUMMARY: 230 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc6
\n------------------------\n\n\n
==723== Memcheck, a memory error detector
==723== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==723== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==723== Command: ./testcase tc6
==723== 
==723== Conditional jump or move depends on uninitialised value(s)
==723==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==723==    by 0x10981B: unallocate_request (server.c:160)
==723==    by 0x10AB14: run_test (testcase.c:90)
==723==    by 0x10AE16: method1 (testcase.c:162)
==723==    by 0x10B35C: main (testcase.c:334)
==723== 
==723== Conditional jump or move depends on uninitialised value(s)
==723==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==723==    by 0x10982E: unallocate_request (server.c:161)
==723==    by 0x10AB14: run_test (testcase.c:90)
==723==    by 0x10AE16: method1 (testcase.c:162)
==723==    by 0x10B35C: main (testcase.c:334)
==723== 
==723== Conditional jump or move depends on uninitialised value(s)
==723==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==723==    by 0x109841: unallocate_request (server.c:162)
==723==    by 0x10AB14: run_test (testcase.c:90)
==723==    by 0x10AE16: method1 (testcase.c:162)
==723==    by 0x10B35C: main (testcase.c:334)
==723== 
==723== Conditional jump or move depends on uninitialised value(s)
==723==    at 0x10989E: unallocate_request (server.c:167)
==723==    by 0x10AB14: run_test (testcase.c:90)
==723==    by 0x10AE16: method1 (testcase.c:162)
==723==    by 0x10B35C: main (testcase.c:334)
==723== 
==723== 
==723== HEAP SUMMARY:
==723==     in use at exit: 0 bytes in 0 blocks
==723==   total heap usage: 4 allocs, 4 frees, 1,324 bytes allocated
==723== 
==723== All heap blocks were freed -- no leaks are possible
==723== 
==723== Use --track-origins=yes to see where uninitialised values come from
==723== For lists of detected and suppressed errors, rerun with: -s
==723== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc7
\n------------------------\n\n\n
==726== Memcheck, a memory error detector
==726== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==726== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==726== Command: ./testcase tc7
==726== 
==726== Conditional jump or move depends on uninitialised value(s)
==726==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==726==    by 0x10981B: unallocate_request (server.c:160)
==726==    by 0x10AB14: run_test (testcase.c:90)
==726==    by 0x10AED3: method2 (testcase.c:172)
==726==    by 0x10B35C: main (testcase.c:334)
==726== 
==726== Conditional jump or move depends on uninitialised value(s)
==726==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==726==    by 0x10982E: unallocate_request (server.c:161)
==726==    by 0x10AB14: run_test (testcase.c:90)
==726==    by 0x10AED3: method2 (testcase.c:172)
==726==    by 0x10B35C: main (testcase.c:334)
==726== 
==726== Conditional jump or move depends on uninitialised value(s)
==726==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==726==    by 0x109841: unallocate_request (server.c:162)
==726==    by 0x10AB14: run_test (testcase.c:90)
==726==    by 0x10AED3: method2 (testcase.c:172)
==726==    by 0x10B35C: main (testcase.c:334)
==726== 
==726== Conditional jump or move depends on uninitialised value(s)
==726==    at 0x10989E: unallocate_request (server.c:167)
==726==    by 0x10AB14: run_test (testcase.c:90)
==726==    by 0x10AED3: method2 (testcase.c:172)
==726==    by 0x10B35C: main (testcase.c:334)
==726== 
==726== 
==726== HEAP SUMMARY:
==726==     in use at exit: 0 bytes in 0 blocks
==726==   total heap usage: 4 allocs, 4 frees, 1,325 bytes allocated
==726== 
==726== All heap blocks were freed -- no leaks are possible
==726== 
==726== Use --track-origins=yes to see where uninitialised values come from
==726== For lists of detected and suppressed errors, rerun with: -s
==726== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc8
\n------------------------\n\n\n
==729== Memcheck, a memory error detector
==729== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==729== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==729== Command: ./testcase tc8
==729== 
==729== Conditional jump or move depends on uninitialised value(s)
==729==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==729==    by 0x10981B: unallocate_request (server.c:160)
==729==    by 0x10AB14: run_test (testcase.c:90)
==729==    by 0x10AF35: method3 (testcase.c:182)
==729==    by 0x10B35C: main (testcase.c:334)
==729== 
==729== Conditional jump or move depends on uninitialised value(s)
==729==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==729==    by 0x10982E: unallocate_request (server.c:161)
==729==    by 0x10AB14: run_test (testcase.c:90)
==729==    by 0x10AF35: method3 (testcase.c:182)
==729==    by 0x10B35C: main (testcase.c:334)
==729== 
==729== Conditional jump or move depends on uninitialised value(s)
==729==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==729==    by 0x109841: unallocate_request (server.c:162)
==729==    by 0x10AB14: run_test (testcase.c:90)
==729==    by 0x10AF35: method3 (testcase.c:182)
==729==    by 0x10B35C: main (testcase.c:334)
==729== 
==729== Conditional jump or move depends on uninitialised value(s)
==729==    at 0x10989E: unallocate_request (server.c:167)
==729==    by 0x10AB14: run_test (testcase.c:90)
==729==    by 0x10AF35: method3 (testcase.c:182)
==729==    by 0x10B35C: main (testcase.c:334)
==729== 
==729== 
==729== HEAP SUMMARY:
==729==     in use at exit: 0 bytes in 0 blocks
==729==   total heap usage: 3 allocs, 3 frees, 301 bytes allocated
==729== 
==729== All heap blocks were freed -- no leaks are possible
==729== 
==729== Use --track-origins=yes to see where uninitialised values come from
==729== For lists of detected and suppressed errors, rerun with: -s
==729== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc9
\n------------------------\n\n\n
==732== Memcheck, a memory error detector
==732== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==732== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==732== Command: ./testcase tc9
==732== 
==732== 
==732== HEAP SUMMARY:
==732==     in use at exit: 0 bytes in 0 blocks
==732==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==732== 
==732== All heap blocks were freed -- no leaks are possible
==732== 
==732== For lists of detected and suppressed errors, rerun with: -s
==732== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc10
\n------------------------\n\n\n
==735== Memcheck, a memory error detector
==735== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==735== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==735== Command: ./testcase tc10
==735== 
==735== 
==735== HEAP SUMMARY:
==735==     in use at exit: 0 bytes in 0 blocks
==735==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==735== 
==735== All heap blocks were freed -- no leaks are possible
==735== 
==735== For lists of detected and suppressed errors, rerun with: -s
==735== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc11
\n------------------------\n\n\n
==738== Memcheck, a memory error detector
==738== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==738== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==738== Command: ./testcase tc11
==738== 
==738== 
==738== HEAP SUMMARY:
==738==     in use at exit: 0 bytes in 0 blocks
==738==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==738== 
==738== All heap blocks were freed -- no leaks are possible
==738== 
==738== For lists of detected and suppressed errors, rerun with: -s
==738== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc12
\n------------------------\n\n\n
==741== Memcheck, a memory error detector
==741== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==741== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==741== Command: ./testcase tc12
==741== 
==741== 
==741== HEAP SUMMARY:
==741==     in use at exit: 0 bytes in 0 blocks
==741==   total heap usage: 7 allocs, 7 frees, 1,346 bytes allocated
==741== 
==741== All heap blocks were freed -- no leaks are possible
==741== 
==741== For lists of detected and suppressed errors, rerun with: -s
==741== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc13
\n------------------------\n\n\n
==744== Memcheck, a memory error detector
==744== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==744== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==744== Command: ./testcase tc13
==744== 
==744== 
==744== HEAP SUMMARY:
==744==     in use at exit: 0 bytes in 0 blocks
==744==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==744== 
==744== All heap blocks were freed -- no leaks are possible
==744== 
==744== For lists of detected and suppressed errors, rerun with: -s
==744== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc1
\n------------------------\n\n\n
==749== Memcheck, a memory error detector
==749== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==749== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==749== Command: ./testcase tc1
==749== 
==749== 
==749== HEAP SUMMARY:
==749==     in use at exit: 0 bytes in 0 blocks
==749==   total heap usage: 7 allocs, 7 frees, 864 bytes allocated
==749== 
==749== All heap blocks were freed -- no leaks are possible
==749== 
==749== For lists of detected and suppressed errors, rerun with: -s
==749== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc1
\n------------------------\n\n\n
==767== Memcheck, a memory error detector
==767== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==767== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==767== Command: ./testcase tc1
==767== 
==767== 
==767== HEAP SUMMARY:
==767==     in use at exit: 0 bytes in 0 blocks
==767==   total heap usage: 7 allocs, 7 frees, 864 bytes allocated
==767== 
==767== All heap blocks were freed -- no leaks are possible
==767== 
==767== For lists of detected and suppressed errors, rerun with: -s
==767== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc2
\n------------------------\n\n\n
==770== Memcheck, a memory error detector
==770== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==770== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==770== Command: ./testcase tc2
==770== 
==770== 
==770== HEAP SUMMARY:
==770==     in use at exit: 0 bytes in 0 blocks
==770==   total heap usage: 9 allocs, 9 frees, 1,946 bytes allocated
==770== 
==770== All heap blocks were freed -- no leaks are possible
==770== 
==770== For lists of detected and suppressed errors, rerun with: -s
==770== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc3
\n------------------------\n\n\n
==773== Memcheck, a memory error detector
==773== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==773== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==773== Command: ./testcase tc3
==773== 
==773== Use of uninitialised value of size 8
==773==    at 0x10A325: create_request (server.c:419)
==773==    by 0x10AAA5: run_test (testcase.c:77)
==773==    by 0x10ACD1: get3 (testcase.c:138)
==773==    by 0x10B35C: main (testcase.c:334)
==773== 
==773== Invalid read of size 1
==773==    at 0x10A325: create_request (server.c:419)
==773==    by 0x10AAA5: run_test (testcase.c:77)
==773==    by 0x10ACD1: get3 (testcase.c:138)
==773==    by 0x10B35C: main (testcase.c:334)
==773==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==773== 
==773== 
==773== Process terminating with default action of signal 11 (SIGSEGV)
==773==  Access not within mapped region at address 0x0
==773==    at 0x10A325: create_request (server.c:419)
==773==    by 0x10AAA5: run_test (testcase.c:77)
==773==    by 0x10ACD1: get3 (testcase.c:138)
==773==    by 0x10B35C: main (testcase.c:334)
==773==  If you believe this happened as a result of a stack
==773==  overflow in your program's main thread (unlikely but
==773==  possible), you can try to increase the size of the
==773==  main thread stack using the --main-stacksize= flag.
==773==  The main thread stack size used in this run was 8388608.
==773== 
==773== HEAP SUMMARY:
==773==     in use at exit: 320 bytes in 5 blocks
==773==   total heap usage: 5 allocs, 0 frees, 320 bytes allocated
==773== 
==773== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==773==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==773==    by 0x109AFB: create_request (server.c:286)
==773==    by 0x10AAA5: run_test (testcase.c:77)
==773==    by 0x10ACD1: get3 (testcase.c:138)
==773==    by 0x10B35C: main (testcase.c:334)
==773== 
==773== 10 bytes in 1 blocks are still reachable in loss record 2 of 5
==773==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==773==    by 0x109DB1: create_request (server.c:342)
==773==    by 0x10AAA5: run_test (testcase.c:77)
==773==    by 0x10ACD1: get3 (testcase.c:138)
==773==    by 0x10B35C: main (testcase.c:334)
==773== 
==773== 10 bytes in 1 blocks are still reachable in loss record 3 of 5
==773==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==773==    by 0x109DEA: create_request (server.c:344)
==773==    by 0x10AAA5: run_test (testcase.c:77)
==773==    by 0x10ACD1: get3 (testcase.c:138)
==773==    by 0x10B35C: main (testcase.c:334)
==773== 
==773== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==773==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==773==    by 0x109A95: create_request (server.c:277)
==773==    by 0x10AAA5: run_test (testcase.c:77)
==773==    by 0x10ACD1: get3 (testcase.c:138)
==773==    by 0x10B35C: main (testcase.c:334)
==773== 
==773== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==773==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==773==    by 0x10AA7D: run_test (testcase.c:73)
==773==    by 0x10ACD1: get3 (testcase.c:138)
==773==    by 0x10B35C: main (testcase.c:334)
==773== 
==773== LEAK SUMMARY:
==773==    definitely lost: 0 bytes in 0 blocks
==773==    indirectly lost: 0 bytes in 0 blocks
==773==      possibly lost: 0 bytes in 0 blocks
==773==    still reachable: 320 bytes in 5 blocks
==773==         suppressed: 0 bytes in 0 blocks
==773== 
==773== Use --track-origins=yes to see where uninitialised values come from
==773== For lists of detected and suppressed errors, rerun with: -s
==773== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc4
\n------------------------\n\n\n
==776== Memcheck, a memory error detector
==776== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==776== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==776== Command: ./testcase tc4
==776== 
==776== 
==776== HEAP SUMMARY:
==776==     in use at exit: 0 bytes in 0 blocks
==776==   total heap usage: 7 allocs, 7 frees, 1,348 bytes allocated
==776== 
==776== All heap blocks were freed -- no leaks are possible
==776== 
==776== For lists of detected and suppressed errors, rerun with: -s
==776== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc5
\n------------------------\n\n\n
==779== Memcheck, a memory error detector
==779== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==779== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==779== Command: ./testcase tc5
==779== 
==779== Invalid read of size 1
==779==    at 0x109E3E: create_request (server.c:352)
==779==    by 0x10AAA5: run_test (testcase.c:77)
==779==    by 0x10AD6D: get5 (testcase.c:148)
==779==    by 0x10B35C: main (testcase.c:334)
==779==  Address 0x4a78140 is 0 bytes after a block of size 256 alloc'd
==779==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==779==    by 0x10AA7D: run_test (testcase.c:73)
==779==    by 0x10AD6D: get5 (testcase.c:148)
==779==    by 0x10B35C: main (testcase.c:334)
==779== 
==779== Conditional jump or move depends on uninitialised value(s)
==779==    at 0x109E43: create_request (server.c:352)
==779==    by 0x10AAA5: run_test (testcase.c:77)
==779==    by 0x10AD6D: get5 (testcase.c:148)
==779==    by 0x10B35C: main (testcase.c:334)
==779== 
==779== Use of uninitialised value of size 8
==779==    at 0x10A325: create_request (server.c:419)
==779==    by 0x10AAA5: run_test (testcase.c:77)
==779==    by 0x10AD6D: get5 (testcase.c:148)
==779==    by 0x10B35C: main (testcase.c:334)
==779== 
==779== Invalid read of size 1
==779==    at 0x10A325: create_request (server.c:419)
==779==    by 0x10AAA5: run_test (testcase.c:77)
==779==    by 0x10AD6D: get5 (testcase.c:148)
==779==    by 0x10B35C: main (testcase.c:334)
==779==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==779== 
==779== 
==779== Process terminating with default action of signal 11 (SIGSEGV)
==779==  Access not within mapped region at address 0x0
==779==    at 0x10A325: create_request (server.c:419)
==779==    by 0x10AAA5: run_test (testcase.c:77)
==779==    by 0x10AD6D: get5 (testcase.c:148)
==779==    by 0x10B35C: main (testcase.c:334)
==779==  If you believe this happened as a result of a stack
==779==  overflow in your program's main thread (unlikely but
==779==  possible), you can try to increase the size of the
==779==  main thread stack using the --main-stacksize= flag.
==779==  The main thread stack size used in this run was 8388608.
==779== 
==779== HEAP SUMMARY:
==779==     in use at exit: 326 bytes in 5 blocks
==779==   total heap usage: 5 allocs, 0 frees, 326 bytes allocated
==779== 
==779== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==779==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==779==    by 0x109AFB: create_request (server.c:286)
==779==    by 0x10AAA5: run_test (testcase.c:77)
==779==    by 0x10AD6D: get5 (testcase.c:148)
==779==    by 0x10B35C: main (testcase.c:334)
==779== 
==779== 13 bytes in 1 blocks are still reachable in loss record 2 of 5
==779==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==779==    by 0x109DB1: create_request (server.c:342)
==779==    by 0x10AAA5: run_test (testcase.c:77)
==779==    by 0x10AD6D: get5 (testcase.c:148)
==779==    by 0x10B35C: main (testcase.c:334)
==779== 
==779== 13 bytes in 1 blocks are still reachable in loss record 3 of 5
==779==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==779==    by 0x109DEA: create_request (server.c:344)
==779==    by 0x10AAA5: run_test (testcase.c:77)
==779==    by 0x10AD6D: get5 (testcase.c:148)
==779==    by 0x10B35C: main (testcase.c:334)
==779== 
==779== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==779==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==779==    by 0x109A95: create_request (server.c:277)
==779==    by 0x10AAA5: run_test (testcase.c:77)
==779==    by 0x10AD6D: get5 (testcase.c:148)
==779==    by 0x10B35C: main (testcase.c:334)
==779== 
==779== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==779==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==779==    by 0x10AA7D: run_test (testcase.c:73)
==779==    by 0x10AD6D: get5 (testcase.c:148)
==779==    by 0x10B35C: main (testcase.c:334)
==779== 
==779== LEAK SUMMARY:
==779==    definitely lost: 0 bytes in 0 blocks
==779==    indirectly lost: 0 bytes in 0 blocks
==779==      possibly lost: 0 bytes in 0 blocks
==779==    still reachable: 326 bytes in 5 blocks
==779==         suppressed: 0 bytes in 0 blocks
==779== 
==779== Use --track-origins=yes to see where uninitialised values come from
==779== For lists of detected and suppressed errors, rerun with: -s
==779== ERROR SUMMARY: 230 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc6
\n------------------------\n\n\n
==782== Memcheck, a memory error detector
==782== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==782== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==782== Command: ./testcase tc6
==782== 
==782== Conditional jump or move depends on uninitialised value(s)
==782==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==782==    by 0x10981B: unallocate_request (server.c:160)
==782==    by 0x10AB14: run_test (testcase.c:90)
==782==    by 0x10AE16: method1 (testcase.c:162)
==782==    by 0x10B35C: main (testcase.c:334)
==782== 
==782== Conditional jump or move depends on uninitialised value(s)
==782==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==782==    by 0x10982E: unallocate_request (server.c:161)
==782==    by 0x10AB14: run_test (testcase.c:90)
==782==    by 0x10AE16: method1 (testcase.c:162)
==782==    by 0x10B35C: main (testcase.c:334)
==782== 
==782== Conditional jump or move depends on uninitialised value(s)
==782==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==782==    by 0x109841: unallocate_request (server.c:162)
==782==    by 0x10AB14: run_test (testcase.c:90)
==782==    by 0x10AE16: method1 (testcase.c:162)
==782==    by 0x10B35C: main (testcase.c:334)
==782== 
==782== Conditional jump or move depends on uninitialised value(s)
==782==    at 0x10989E: unallocate_request (server.c:167)
==782==    by 0x10AB14: run_test (testcase.c:90)
==782==    by 0x10AE16: method1 (testcase.c:162)
==782==    by 0x10B35C: main (testcase.c:334)
==782== 
==782== 
==782== HEAP SUMMARY:
==782==     in use at exit: 0 bytes in 0 blocks
==782==   total heap usage: 4 allocs, 4 frees, 1,324 bytes allocated
==782== 
==782== All heap blocks were freed -- no leaks are possible
==782== 
==782== Use --track-origins=yes to see where uninitialised values come from
==782== For lists of detected and suppressed errors, rerun with: -s
==782== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc7
\n------------------------\n\n\n
==785== Memcheck, a memory error detector
==785== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==785== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==785== Command: ./testcase tc7
==785== 
==785== Conditional jump or move depends on uninitialised value(s)
==785==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==785==    by 0x10981B: unallocate_request (server.c:160)
==785==    by 0x10AB14: run_test (testcase.c:90)
==785==    by 0x10AED3: method2 (testcase.c:172)
==785==    by 0x10B35C: main (testcase.c:334)
==785== 
==785== Conditional jump or move depends on uninitialised value(s)
==785==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==785==    by 0x10982E: unallocate_request (server.c:161)
==785==    by 0x10AB14: run_test (testcase.c:90)
==785==    by 0x10AED3: method2 (testcase.c:172)
==785==    by 0x10B35C: main (testcase.c:334)
==785== 
==785== Conditional jump or move depends on uninitialised value(s)
==785==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==785==    by 0x109841: unallocate_request (server.c:162)
==785==    by 0x10AB14: run_test (testcase.c:90)
==785==    by 0x10AED3: method2 (testcase.c:172)
==785==    by 0x10B35C: main (testcase.c:334)
==785== 
==785== Conditional jump or move depends on uninitialised value(s)
==785==    at 0x10989E: unallocate_request (server.c:167)
==785==    by 0x10AB14: run_test (testcase.c:90)
==785==    by 0x10AED3: method2 (testcase.c:172)
==785==    by 0x10B35C: main (testcase.c:334)
==785== 
==785== 
==785== HEAP SUMMARY:
==785==     in use at exit: 0 bytes in 0 blocks
==785==   total heap usage: 4 allocs, 4 frees, 1,325 bytes allocated
==785== 
==785== All heap blocks were freed -- no leaks are possible
==785== 
==785== Use --track-origins=yes to see where uninitialised values come from
==785== For lists of detected and suppressed errors, rerun with: -s
==785== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc8
\n------------------------\n\n\n
==788== Memcheck, a memory error detector
==788== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==788== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==788== Command: ./testcase tc8
==788== 
==788== Conditional jump or move depends on uninitialised value(s)
==788==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==788==    by 0x10981B: unallocate_request (server.c:160)
==788==    by 0x10AB14: run_test (testcase.c:90)
==788==    by 0x10AF35: method3 (testcase.c:182)
==788==    by 0x10B35C: main (testcase.c:334)
==788== 
==788== Conditional jump or move depends on uninitialised value(s)
==788==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==788==    by 0x10982E: unallocate_request (server.c:161)
==788==    by 0x10AB14: run_test (testcase.c:90)
==788==    by 0x10AF35: method3 (testcase.c:182)
==788==    by 0x10B35C: main (testcase.c:334)
==788== 
==788== Conditional jump or move depends on uninitialised value(s)
==788==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==788==    by 0x109841: unallocate_request (server.c:162)
==788==    by 0x10AB14: run_test (testcase.c:90)
==788==    by 0x10AF35: method3 (testcase.c:182)
==788==    by 0x10B35C: main (testcase.c:334)
==788== 
==788== Conditional jump or move depends on uninitialised value(s)
==788==    at 0x10989E: unallocate_request (server.c:167)
==788==    by 0x10AB14: run_test (testcase.c:90)
==788==    by 0x10AF35: method3 (testcase.c:182)
==788==    by 0x10B35C: main (testcase.c:334)
==788== 
==788== 
==788== HEAP SUMMARY:
==788==     in use at exit: 0 bytes in 0 blocks
==788==   total heap usage: 3 allocs, 3 frees, 301 bytes allocated
==788== 
==788== All heap blocks were freed -- no leaks are possible
==788== 
==788== Use --track-origins=yes to see where uninitialised values come from
==788== For lists of detected and suppressed errors, rerun with: -s
==788== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc9
\n------------------------\n\n\n
==791== Memcheck, a memory error detector
==791== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==791== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==791== Command: ./testcase tc9
==791== 
==791== 
==791== HEAP SUMMARY:
==791==     in use at exit: 0 bytes in 0 blocks
==791==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==791== 
==791== All heap blocks were freed -- no leaks are possible
==791== 
==791== For lists of detected and suppressed errors, rerun with: -s
==791== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc10
\n------------------------\n\n\n
==794== Memcheck, a memory error detector
==794== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==794== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==794== Command: ./testcase tc10
==794== 
==794== 
==794== HEAP SUMMARY:
==794==     in use at exit: 0 bytes in 0 blocks
==794==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==794== 
==794== All heap blocks were freed -- no leaks are possible
==794== 
==794== For lists of detected and suppressed errors, rerun with: -s
==794== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc11
\n------------------------\n\n\n
==797== Memcheck, a memory error detector
==797== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==797== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==797== Command: ./testcase tc11
==797== 
==797== 
==797== HEAP SUMMARY:
==797==     in use at exit: 0 bytes in 0 blocks
==797==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==797== 
==797== All heap blocks were freed -- no leaks are possible
==797== 
==797== For lists of detected and suppressed errors, rerun with: -s
==797== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc12
\n------------------------\n\n\n
==800== Memcheck, a memory error detector
==800== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==800== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==800== Command: ./testcase tc12
==800== 
==800== 
==800== HEAP SUMMARY:
==800==     in use at exit: 0 bytes in 0 blocks
==800==   total heap usage: 7 allocs, 7 frees, 1,346 bytes allocated
==800== 
==800== All heap blocks were freed -- no leaks are possible
==800== 
==800== For lists of detected and suppressed errors, rerun with: -s
==800== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc13
\n------------------------\n\n\n
==803== Memcheck, a memory error detector
==803== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==803== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==803== Command: ./testcase tc13
==803== 
==803== 
==803== HEAP SUMMARY:
==803==     in use at exit: 0 bytes in 0 blocks
==803==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==803== 
==803== All heap blocks were freed -- no leaks are possible
==803== 
==803== For lists of detected and suppressed errors, rerun with: -s
==803== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc1
\n------------------------\n\n\n
==808== Memcheck, a memory error detector
==808== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==808== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==808== Command: ./testcase tc1
==808== 
==808== 
==808== HEAP SUMMARY:
==808==     in use at exit: 0 bytes in 0 blocks
==808==   total heap usage: 7 allocs, 7 frees, 864 bytes allocated
==808== 
==808== All heap blocks were freed -- no leaks are possible
==808== 
==808== For lists of detected and suppressed errors, rerun with: -s
==808== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc2
\n------------------------\n\n\n
==811== Memcheck, a memory error detector
==811== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==811== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==811== Command: ./testcase tc2
==811== 
==811== 
==811== HEAP SUMMARY:
==811==     in use at exit: 0 bytes in 0 blocks
==811==   total heap usage: 9 allocs, 9 frees, 1,946 bytes allocated
==811== 
==811== All heap blocks were freed -- no leaks are possible
==811== 
==811== For lists of detected and suppressed errors, rerun with: -s
==811== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc3
\n------------------------\n\n\n
==814== Memcheck, a memory error detector
==814== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==814== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==814== Command: ./testcase tc3
==814== 
==814== Use of uninitialised value of size 8
==814==    at 0x10A325: create_request (server.c:419)
==814==    by 0x10AAA5: run_test (testcase.c:77)
==814==    by 0x10ACD1: get3 (testcase.c:138)
==814==    by 0x10B35C: main (testcase.c:334)
==814== 
==814== Invalid read of size 1
==814==    at 0x10A325: create_request (server.c:419)
==814==    by 0x10AAA5: run_test (testcase.c:77)
==814==    by 0x10ACD1: get3 (testcase.c:138)
==814==    by 0x10B35C: main (testcase.c:334)
==814==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==814== 
==814== 
==814== Process terminating with default action of signal 11 (SIGSEGV)
==814==  Access not within mapped region at address 0x0
==814==    at 0x10A325: create_request (server.c:419)
==814==    by 0x10AAA5: run_test (testcase.c:77)
==814==    by 0x10ACD1: get3 (testcase.c:138)
==814==    by 0x10B35C: main (testcase.c:334)
==814==  If you believe this happened as a result of a stack
==814==  overflow in your program's main thread (unlikely but
==814==  possible), you can try to increase the size of the
==814==  main thread stack using the --main-stacksize= flag.
==814==  The main thread stack size used in this run was 8388608.
==814== 
==814== HEAP SUMMARY:
==814==     in use at exit: 320 bytes in 5 blocks
==814==   total heap usage: 5 allocs, 0 frees, 320 bytes allocated
==814== 
==814== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==814==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==814==    by 0x109AFB: create_request (server.c:286)
==814==    by 0x10AAA5: run_test (testcase.c:77)
==814==    by 0x10ACD1: get3 (testcase.c:138)
==814==    by 0x10B35C: main (testcase.c:334)
==814== 
==814== 10 bytes in 1 blocks are still reachable in loss record 2 of 5
==814==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==814==    by 0x109DB1: create_request (server.c:342)
==814==    by 0x10AAA5: run_test (testcase.c:77)
==814==    by 0x10ACD1: get3 (testcase.c:138)
==814==    by 0x10B35C: main (testcase.c:334)
==814== 
==814== 10 bytes in 1 blocks are still reachable in loss record 3 of 5
==814==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==814==    by 0x109DEA: create_request (server.c:344)
==814==    by 0x10AAA5: run_test (testcase.c:77)
==814==    by 0x10ACD1: get3 (testcase.c:138)
==814==    by 0x10B35C: main (testcase.c:334)
==814== 
==814== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==814==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==814==    by 0x109A95: create_request (server.c:277)
==814==    by 0x10AAA5: run_test (testcase.c:77)
==814==    by 0x10ACD1: get3 (testcase.c:138)
==814==    by 0x10B35C: main (testcase.c:334)
==814== 
==814== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==814==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==814==    by 0x10AA7D: run_test (testcase.c:73)
==814==    by 0x10ACD1: get3 (testcase.c:138)
==814==    by 0x10B35C: main (testcase.c:334)
==814== 
==814== LEAK SUMMARY:
==814==    definitely lost: 0 bytes in 0 blocks
==814==    indirectly lost: 0 bytes in 0 blocks
==814==      possibly lost: 0 bytes in 0 blocks
==814==    still reachable: 320 bytes in 5 blocks
==814==         suppressed: 0 bytes in 0 blocks
==814== 
==814== Use --track-origins=yes to see where uninitialised values come from
==814== For lists of detected and suppressed errors, rerun with: -s
==814== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc4
\n------------------------\n\n\n
==817== Memcheck, a memory error detector
==817== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==817== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==817== Command: ./testcase tc4
==817== 
==817== 
==817== HEAP SUMMARY:
==817==     in use at exit: 0 bytes in 0 blocks
==817==   total heap usage: 7 allocs, 7 frees, 1,348 bytes allocated
==817== 
==817== All heap blocks were freed -- no leaks are possible
==817== 
==817== For lists of detected and suppressed errors, rerun with: -s
==817== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc5
\n------------------------\n\n\n
==820== Memcheck, a memory error detector
==820== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==820== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==820== Command: ./testcase tc5
==820== 
==820== Invalid read of size 1
==820==    at 0x109E3E: create_request (server.c:352)
==820==    by 0x10AAA5: run_test (testcase.c:77)
==820==    by 0x10AD6D: get5 (testcase.c:148)
==820==    by 0x10B35C: main (testcase.c:334)
==820==  Address 0x4a78140 is 0 bytes after a block of size 256 alloc'd
==820==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==820==    by 0x10AA7D: run_test (testcase.c:73)
==820==    by 0x10AD6D: get5 (testcase.c:148)
==820==    by 0x10B35C: main (testcase.c:334)
==820== 
==820== Conditional jump or move depends on uninitialised value(s)
==820==    at 0x109E43: create_request (server.c:352)
==820==    by 0x10AAA5: run_test (testcase.c:77)
==820==    by 0x10AD6D: get5 (testcase.c:148)
==820==    by 0x10B35C: main (testcase.c:334)
==820== 
==820== Use of uninitialised value of size 8
==820==    at 0x10A325: create_request (server.c:419)
==820==    by 0x10AAA5: run_test (testcase.c:77)
==820==    by 0x10AD6D: get5 (testcase.c:148)
==820==    by 0x10B35C: main (testcase.c:334)
==820== 
==820== Invalid read of size 1
==820==    at 0x10A325: create_request (server.c:419)
==820==    by 0x10AAA5: run_test (testcase.c:77)
==820==    by 0x10AD6D: get5 (testcase.c:148)
==820==    by 0x10B35C: main (testcase.c:334)
==820==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==820== 
==820== 
==820== Process terminating with default action of signal 11 (SIGSEGV)
==820==  Access not within mapped region at address 0x0
==820==    at 0x10A325: create_request (server.c:419)
==820==    by 0x10AAA5: run_test (testcase.c:77)
==820==    by 0x10AD6D: get5 (testcase.c:148)
==820==    by 0x10B35C: main (testcase.c:334)
==820==  If you believe this happened as a result of a stack
==820==  overflow in your program's main thread (unlikely but
==820==  possible), you can try to increase the size of the
==820==  main thread stack using the --main-stacksize= flag.
==820==  The main thread stack size used in this run was 8388608.
==820== 
==820== HEAP SUMMARY:
==820==     in use at exit: 326 bytes in 5 blocks
==820==   total heap usage: 5 allocs, 0 frees, 326 bytes allocated
==820== 
==820== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==820==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==820==    by 0x109AFB: create_request (server.c:286)
==820==    by 0x10AAA5: run_test (testcase.c:77)
==820==    by 0x10AD6D: get5 (testcase.c:148)
==820==    by 0x10B35C: main (testcase.c:334)
==820== 
==820== 13 bytes in 1 blocks are still reachable in loss record 2 of 5
==820==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==820==    by 0x109DB1: create_request (server.c:342)
==820==    by 0x10AAA5: run_test (testcase.c:77)
==820==    by 0x10AD6D: get5 (testcase.c:148)
==820==    by 0x10B35C: main (testcase.c:334)
==820== 
==820== 13 bytes in 1 blocks are still reachable in loss record 3 of 5
==820==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==820==    by 0x109DEA: create_request (server.c:344)
==820==    by 0x10AAA5: run_test (testcase.c:77)
==820==    by 0x10AD6D: get5 (testcase.c:148)
==820==    by 0x10B35C: main (testcase.c:334)
==820== 
==820== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==820==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==820==    by 0x109A95: create_request (server.c:277)
==820==    by 0x10AAA5: run_test (testcase.c:77)
==820==    by 0x10AD6D: get5 (testcase.c:148)
==820==    by 0x10B35C: main (testcase.c:334)
==820== 
==820== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==820==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==820==    by 0x10AA7D: run_test (testcase.c:73)
==820==    by 0x10AD6D: get5 (testcase.c:148)
==820==    by 0x10B35C: main (testcase.c:334)
==820== 
==820== LEAK SUMMARY:
==820==    definitely lost: 0 bytes in 0 blocks
==820==    indirectly lost: 0 bytes in 0 blocks
==820==      possibly lost: 0 bytes in 0 blocks
==820==    still reachable: 326 bytes in 5 blocks
==820==         suppressed: 0 bytes in 0 blocks
==820== 
==820== Use --track-origins=yes to see where uninitialised values come from
==820== For lists of detected and suppressed errors, rerun with: -s
==820== ERROR SUMMARY: 230 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc6
\n------------------------\n\n\n
==823== Memcheck, a memory error detector
==823== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==823== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==823== Command: ./testcase tc6
==823== 
==823== Conditional jump or move depends on uninitialised value(s)
==823==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==823==    by 0x10981B: unallocate_request (server.c:160)
==823==    by 0x10AB14: run_test (testcase.c:90)
==823==    by 0x10AE16: method1 (testcase.c:162)
==823==    by 0x10B35C: main (testcase.c:334)
==823== 
==823== Conditional jump or move depends on uninitialised value(s)
==823==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==823==    by 0x10982E: unallocate_request (server.c:161)
==823==    by 0x10AB14: run_test (testcase.c:90)
==823==    by 0x10AE16: method1 (testcase.c:162)
==823==    by 0x10B35C: main (testcase.c:334)
==823== 
==823== Conditional jump or move depends on uninitialised value(s)
==823==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==823==    by 0x109841: unallocate_request (server.c:162)
==823==    by 0x10AB14: run_test (testcase.c:90)
==823==    by 0x10AE16: method1 (testcase.c:162)
==823==    by 0x10B35C: main (testcase.c:334)
==823== 
==823== Conditional jump or move depends on uninitialised value(s)
==823==    at 0x10989E: unallocate_request (server.c:167)
==823==    by 0x10AB14: run_test (testcase.c:90)
==823==    by 0x10AE16: method1 (testcase.c:162)
==823==    by 0x10B35C: main (testcase.c:334)
==823== 
==823== 
==823== HEAP SUMMARY:
==823==     in use at exit: 0 bytes in 0 blocks
==823==   total heap usage: 4 allocs, 4 frees, 1,324 bytes allocated
==823== 
==823== All heap blocks were freed -- no leaks are possible
==823== 
==823== Use --track-origins=yes to see where uninitialised values come from
==823== For lists of detected and suppressed errors, rerun with: -s
==823== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc7
\n------------------------\n\n\n
==826== Memcheck, a memory error detector
==826== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==826== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==826== Command: ./testcase tc7
==826== 
==826== Conditional jump or move depends on uninitialised value(s)
==826==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==826==    by 0x10981B: unallocate_request (server.c:160)
==826==    by 0x10AB14: run_test (testcase.c:90)
==826==    by 0x10AED3: method2 (testcase.c:172)
==826==    by 0x10B35C: main (testcase.c:334)
==826== 
==826== Conditional jump or move depends on uninitialised value(s)
==826==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==826==    by 0x10982E: unallocate_request (server.c:161)
==826==    by 0x10AB14: run_test (testcase.c:90)
==826==    by 0x10AED3: method2 (testcase.c:172)
==826==    by 0x10B35C: main (testcase.c:334)
==826== 
==826== Conditional jump or move depends on uninitialised value(s)
==826==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==826==    by 0x109841: unallocate_request (server.c:162)
==826==    by 0x10AB14: run_test (testcase.c:90)
==826==    by 0x10AED3: method2 (testcase.c:172)
==826==    by 0x10B35C: main (testcase.c:334)
==826== 
==826== Conditional jump or move depends on uninitialised value(s)
==826==    at 0x10989E: unallocate_request (server.c:167)
==826==    by 0x10AB14: run_test (testcase.c:90)
==826==    by 0x10AED3: method2 (testcase.c:172)
==826==    by 0x10B35C: main (testcase.c:334)
==826== 
==826== 
==826== HEAP SUMMARY:
==826==     in use at exit: 0 bytes in 0 blocks
==826==   total heap usage: 4 allocs, 4 frees, 1,325 bytes allocated
==826== 
==826== All heap blocks were freed -- no leaks are possible
==826== 
==826== Use --track-origins=yes to see where uninitialised values come from
==826== For lists of detected and suppressed errors, rerun with: -s
==826== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc8
\n------------------------\n\n\n
==829== Memcheck, a memory error detector
==829== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==829== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==829== Command: ./testcase tc8
==829== 
==829== Conditional jump or move depends on uninitialised value(s)
==829==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==829==    by 0x10981B: unallocate_request (server.c:160)
==829==    by 0x10AB14: run_test (testcase.c:90)
==829==    by 0x10AF35: method3 (testcase.c:182)
==829==    by 0x10B35C: main (testcase.c:334)
==829== 
==829== Conditional jump or move depends on uninitialised value(s)
==829==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==829==    by 0x10982E: unallocate_request (server.c:161)
==829==    by 0x10AB14: run_test (testcase.c:90)
==829==    by 0x10AF35: method3 (testcase.c:182)
==829==    by 0x10B35C: main (testcase.c:334)
==829== 
==829== Conditional jump or move depends on uninitialised value(s)
==829==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==829==    by 0x109841: unallocate_request (server.c:162)
==829==    by 0x10AB14: run_test (testcase.c:90)
==829==    by 0x10AF35: method3 (testcase.c:182)
==829==    by 0x10B35C: main (testcase.c:334)
==829== 
==829== Conditional jump or move depends on uninitialised value(s)
==829==    at 0x10989E: unallocate_request (server.c:167)
==829==    by 0x10AB14: run_test (testcase.c:90)
==829==    by 0x10AF35: method3 (testcase.c:182)
==829==    by 0x10B35C: main (testcase.c:334)
==829== 
==829== 
==829== HEAP SUMMARY:
==829==     in use at exit: 0 bytes in 0 blocks
==829==   total heap usage: 3 allocs, 3 frees, 301 bytes allocated
==829== 
==829== All heap blocks were freed -- no leaks are possible
==829== 
==829== Use --track-origins=yes to see where uninitialised values come from
==829== For lists of detected and suppressed errors, rerun with: -s
==829== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc9
\n------------------------\n\n\n
==832== Memcheck, a memory error detector
==832== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==832== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==832== Command: ./testcase tc9
==832== 
==832== 
==832== HEAP SUMMARY:
==832==     in use at exit: 0 bytes in 0 blocks
==832==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==832== 
==832== All heap blocks were freed -- no leaks are possible
==832== 
==832== For lists of detected and suppressed errors, rerun with: -s
==832== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc10
\n------------------------\n\n\n
==835== Memcheck, a memory error detector
==835== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==835== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==835== Command: ./testcase tc10
==835== 
==835== 
==835== HEAP SUMMARY:
==835==     in use at exit: 0 bytes in 0 blocks
==835==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==835== 
==835== All heap blocks were freed -- no leaks are possible
==835== 
==835== For lists of detected and suppressed errors, rerun with: -s
==835== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc11
\n------------------------\n\n\n
==838== Memcheck, a memory error detector
==838== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==838== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==838== Command: ./testcase tc11
==838== 
==838== 
==838== HEAP SUMMARY:
==838==     in use at exit: 0 bytes in 0 blocks
==838==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==838== 
==838== All heap blocks were freed -- no leaks are possible
==838== 
==838== For lists of detected and suppressed errors, rerun with: -s
==838== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc12
\n------------------------\n\n\n
==841== Memcheck, a memory error detector
==841== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==841== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==841== Command: ./testcase tc12
==841== 
==841== 
==841== HEAP SUMMARY:
==841==     in use at exit: 0 bytes in 0 blocks
==841==   total heap usage: 7 allocs, 7 frees, 1,346 bytes allocated
==841== 
==841== All heap blocks were freed -- no leaks are possible
==841== 
==841== For lists of detected and suppressed errors, rerun with: -s
==841== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc13
\n------------------------\n\n\n
==844== Memcheck, a memory error detector
==844== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==844== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==844== Command: ./testcase tc13
==844== 
==844== 
==844== HEAP SUMMARY:
==844==     in use at exit: 0 bytes in 0 blocks
==844==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==844== 
==844== All heap blocks were freed -- no leaks are possible
==844== 
==844== For lists of detected and suppressed errors, rerun with: -s
==844== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc1
\n------------------------\n\n\n
==849== Memcheck, a memory error detector
==849== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==849== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==849== Command: ./testcase tc1
==849== 
==849== 
==849== HEAP SUMMARY:
==849==     in use at exit: 0 bytes in 0 blocks
==849==   total heap usage: 7 allocs, 7 frees, 864 bytes allocated
==849== 
==849== All heap blocks were freed -- no leaks are possible
==849== 
==849== For lists of detected and suppressed errors, rerun with: -s
==849== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc2
\n------------------------\n\n\n
==852== Memcheck, a memory error detector
==852== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==852== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==852== Command: ./testcase tc2
==852== 
==852== 
==852== HEAP SUMMARY:
==852==     in use at exit: 0 bytes in 0 blocks
==852==   total heap usage: 9 allocs, 9 frees, 1,946 bytes allocated
==852== 
==852== All heap blocks were freed -- no leaks are possible
==852== 
==852== For lists of detected and suppressed errors, rerun with: -s
==852== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc3
\n------------------------\n\n\n
==855== Memcheck, a memory error detector
==855== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==855== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==855== Command: ./testcase tc3
==855== 
==855== Use of uninitialised value of size 8
==855==    at 0x10A325: create_request (server.c:419)
==855==    by 0x10AAA5: run_test (testcase.c:77)
==855==    by 0x10ACD1: get3 (testcase.c:138)
==855==    by 0x10B35C: main (testcase.c:334)
==855== 
==855== Invalid read of size 1
==855==    at 0x10A325: create_request (server.c:419)
==855==    by 0x10AAA5: run_test (testcase.c:77)
==855==    by 0x10ACD1: get3 (testcase.c:138)
==855==    by 0x10B35C: main (testcase.c:334)
==855==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==855== 
==855== 
==855== Process terminating with default action of signal 11 (SIGSEGV)
==855==  Access not within mapped region at address 0x0
==855==    at 0x10A325: create_request (server.c:419)
==855==    by 0x10AAA5: run_test (testcase.c:77)
==855==    by 0x10ACD1: get3 (testcase.c:138)
==855==    by 0x10B35C: main (testcase.c:334)
==855==  If you believe this happened as a result of a stack
==855==  overflow in your program's main thread (unlikely but
==855==  possible), you can try to increase the size of the
==855==  main thread stack using the --main-stacksize= flag.
==855==  The main thread stack size used in this run was 8388608.
==855== 
==855== HEAP SUMMARY:
==855==     in use at exit: 320 bytes in 5 blocks
==855==   total heap usage: 5 allocs, 0 frees, 320 bytes allocated
==855== 
==855== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==855==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==855==    by 0x109AFB: create_request (server.c:286)
==855==    by 0x10AAA5: run_test (testcase.c:77)
==855==    by 0x10ACD1: get3 (testcase.c:138)
==855==    by 0x10B35C: main (testcase.c:334)
==855== 
==855== 10 bytes in 1 blocks are still reachable in loss record 2 of 5
==855==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==855==    by 0x109DB1: create_request (server.c:342)
==855==    by 0x10AAA5: run_test (testcase.c:77)
==855==    by 0x10ACD1: get3 (testcase.c:138)
==855==    by 0x10B35C: main (testcase.c:334)
==855== 
==855== 10 bytes in 1 blocks are still reachable in loss record 3 of 5
==855==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==855==    by 0x109DEA: create_request (server.c:344)
==855==    by 0x10AAA5: run_test (testcase.c:77)
==855==    by 0x10ACD1: get3 (testcase.c:138)
==855==    by 0x10B35C: main (testcase.c:334)
==855== 
==855== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==855==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==855==    by 0x109A95: create_request (server.c:277)
==855==    by 0x10AAA5: run_test (testcase.c:77)
==855==    by 0x10ACD1: get3 (testcase.c:138)
==855==    by 0x10B35C: main (testcase.c:334)
==855== 
==855== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==855==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==855==    by 0x10AA7D: run_test (testcase.c:73)
==855==    by 0x10ACD1: get3 (testcase.c:138)
==855==    by 0x10B35C: main (testcase.c:334)
==855== 
==855== LEAK SUMMARY:
==855==    definitely lost: 0 bytes in 0 blocks
==855==    indirectly lost: 0 bytes in 0 blocks
==855==      possibly lost: 0 bytes in 0 blocks
==855==    still reachable: 320 bytes in 5 blocks
==855==         suppressed: 0 bytes in 0 blocks
==855== 
==855== Use --track-origins=yes to see where uninitialised values come from
==855== For lists of detected and suppressed errors, rerun with: -s
==855== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc4
\n------------------------\n\n\n
==858== Memcheck, a memory error detector
==858== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==858== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==858== Command: ./testcase tc4
==858== 
==858== 
==858== HEAP SUMMARY:
==858==     in use at exit: 0 bytes in 0 blocks
==858==   total heap usage: 7 allocs, 7 frees, 1,348 bytes allocated
==858== 
==858== All heap blocks were freed -- no leaks are possible
==858== 
==858== For lists of detected and suppressed errors, rerun with: -s
==858== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc5
\n------------------------\n\n\n
==861== Memcheck, a memory error detector
==861== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==861== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==861== Command: ./testcase tc5
==861== 
==861== Invalid read of size 1
==861==    at 0x109E3E: create_request (server.c:352)
==861==    by 0x10AAA5: run_test (testcase.c:77)
==861==    by 0x10AD6D: get5 (testcase.c:148)
==861==    by 0x10B35C: main (testcase.c:334)
==861==  Address 0x4a78140 is 0 bytes after a block of size 256 alloc'd
==861==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==861==    by 0x10AA7D: run_test (testcase.c:73)
==861==    by 0x10AD6D: get5 (testcase.c:148)
==861==    by 0x10B35C: main (testcase.c:334)
==861== 
==861== Conditional jump or move depends on uninitialised value(s)
==861==    at 0x109E43: create_request (server.c:352)
==861==    by 0x10AAA5: run_test (testcase.c:77)
==861==    by 0x10AD6D: get5 (testcase.c:148)
==861==    by 0x10B35C: main (testcase.c:334)
==861== 
==861== Use of uninitialised value of size 8
==861==    at 0x10A325: create_request (server.c:419)
==861==    by 0x10AAA5: run_test (testcase.c:77)
==861==    by 0x10AD6D: get5 (testcase.c:148)
==861==    by 0x10B35C: main (testcase.c:334)
==861== 
==861== Invalid read of size 1
==861==    at 0x10A325: create_request (server.c:419)
==861==    by 0x10AAA5: run_test (testcase.c:77)
==861==    by 0x10AD6D: get5 (testcase.c:148)
==861==    by 0x10B35C: main (testcase.c:334)
==861==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==861== 
==861== 
==861== Process terminating with default action of signal 11 (SIGSEGV)
==861==  Access not within mapped region at address 0x0
==861==    at 0x10A325: create_request (server.c:419)
==861==    by 0x10AAA5: run_test (testcase.c:77)
==861==    by 0x10AD6D: get5 (testcase.c:148)
==861==    by 0x10B35C: main (testcase.c:334)
==861==  If you believe this happened as a result of a stack
==861==  overflow in your program's main thread (unlikely but
==861==  possible), you can try to increase the size of the
==861==  main thread stack using the --main-stacksize= flag.
==861==  The main thread stack size used in this run was 8388608.
==861== 
==861== HEAP SUMMARY:
==861==     in use at exit: 326 bytes in 5 blocks
==861==   total heap usage: 5 allocs, 0 frees, 326 bytes allocated
==861== 
==861== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==861==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==861==    by 0x109AFB: create_request (server.c:286)
==861==    by 0x10AAA5: run_test (testcase.c:77)
==861==    by 0x10AD6D: get5 (testcase.c:148)
==861==    by 0x10B35C: main (testcase.c:334)
==861== 
==861== 13 bytes in 1 blocks are still reachable in loss record 2 of 5
==861==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==861==    by 0x109DB1: create_request (server.c:342)
==861==    by 0x10AAA5: run_test (testcase.c:77)
==861==    by 0x10AD6D: get5 (testcase.c:148)
==861==    by 0x10B35C: main (testcase.c:334)
==861== 
==861== 13 bytes in 1 blocks are still reachable in loss record 3 of 5
==861==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==861==    by 0x109DEA: create_request (server.c:344)
==861==    by 0x10AAA5: run_test (testcase.c:77)
==861==    by 0x10AD6D: get5 (testcase.c:148)
==861==    by 0x10B35C: main (testcase.c:334)
==861== 
==861== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==861==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==861==    by 0x109A95: create_request (server.c:277)
==861==    by 0x10AAA5: run_test (testcase.c:77)
==861==    by 0x10AD6D: get5 (testcase.c:148)
==861==    by 0x10B35C: main (testcase.c:334)
==861== 
==861== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==861==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==861==    by 0x10AA7D: run_test (testcase.c:73)
==861==    by 0x10AD6D: get5 (testcase.c:148)
==861==    by 0x10B35C: main (testcase.c:334)
==861== 
==861== LEAK SUMMARY:
==861==    definitely lost: 0 bytes in 0 blocks
==861==    indirectly lost: 0 bytes in 0 blocks
==861==      possibly lost: 0 bytes in 0 blocks
==861==    still reachable: 326 bytes in 5 blocks
==861==         suppressed: 0 bytes in 0 blocks
==861== 
==861== Use --track-origins=yes to see where uninitialised values come from
==861== For lists of detected and suppressed errors, rerun with: -s
==861== ERROR SUMMARY: 230 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc6
\n------------------------\n\n\n
==864== Memcheck, a memory error detector
==864== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==864== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==864== Command: ./testcase tc6
==864== 
==864== Conditional jump or move depends on uninitialised value(s)
==864==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==864==    by 0x10981B: unallocate_request (server.c:160)
==864==    by 0x10AB14: run_test (testcase.c:90)
==864==    by 0x10AE16: method1 (testcase.c:162)
==864==    by 0x10B35C: main (testcase.c:334)
==864== 
==864== Conditional jump or move depends on uninitialised value(s)
==864==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==864==    by 0x10982E: unallocate_request (server.c:161)
==864==    by 0x10AB14: run_test (testcase.c:90)
==864==    by 0x10AE16: method1 (testcase.c:162)
==864==    by 0x10B35C: main (testcase.c:334)
==864== 
==864== Conditional jump or move depends on uninitialised value(s)
==864==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==864==    by 0x109841: unallocate_request (server.c:162)
==864==    by 0x10AB14: run_test (testcase.c:90)
==864==    by 0x10AE16: method1 (testcase.c:162)
==864==    by 0x10B35C: main (testcase.c:334)
==864== 
==864== Conditional jump or move depends on uninitialised value(s)
==864==    at 0x10989E: unallocate_request (server.c:167)
==864==    by 0x10AB14: run_test (testcase.c:90)
==864==    by 0x10AE16: method1 (testcase.c:162)
==864==    by 0x10B35C: main (testcase.c:334)
==864== 
==864== 
==864== HEAP SUMMARY:
==864==     in use at exit: 0 bytes in 0 blocks
==864==   total heap usage: 4 allocs, 4 frees, 1,324 bytes allocated
==864== 
==864== All heap blocks were freed -- no leaks are possible
==864== 
==864== Use --track-origins=yes to see where uninitialised values come from
==864== For lists of detected and suppressed errors, rerun with: -s
==864== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc7
\n------------------------\n\n\n
==867== Memcheck, a memory error detector
==867== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==867== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==867== Command: ./testcase tc7
==867== 
==867== Conditional jump or move depends on uninitialised value(s)
==867==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==867==    by 0x10981B: unallocate_request (server.c:160)
==867==    by 0x10AB14: run_test (testcase.c:90)
==867==    by 0x10AED3: method2 (testcase.c:172)
==867==    by 0x10B35C: main (testcase.c:334)
==867== 
==867== Conditional jump or move depends on uninitialised value(s)
==867==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==867==    by 0x10982E: unallocate_request (server.c:161)
==867==    by 0x10AB14: run_test (testcase.c:90)
==867==    by 0x10AED3: method2 (testcase.c:172)
==867==    by 0x10B35C: main (testcase.c:334)
==867== 
==867== Conditional jump or move depends on uninitialised value(s)
==867==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==867==    by 0x109841: unallocate_request (server.c:162)
==867==    by 0x10AB14: run_test (testcase.c:90)
==867==    by 0x10AED3: method2 (testcase.c:172)
==867==    by 0x10B35C: main (testcase.c:334)
==867== 
==867== Conditional jump or move depends on uninitialised value(s)
==867==    at 0x10989E: unallocate_request (server.c:167)
==867==    by 0x10AB14: run_test (testcase.c:90)
==867==    by 0x10AED3: method2 (testcase.c:172)
==867==    by 0x10B35C: main (testcase.c:334)
==867== 
==867== 
==867== HEAP SUMMARY:
==867==     in use at exit: 0 bytes in 0 blocks
==867==   total heap usage: 4 allocs, 4 frees, 1,325 bytes allocated
==867== 
==867== All heap blocks were freed -- no leaks are possible
==867== 
==867== Use --track-origins=yes to see where uninitialised values come from
==867== For lists of detected and suppressed errors, rerun with: -s
==867== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc8
\n------------------------\n\n\n
==870== Memcheck, a memory error detector
==870== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==870== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==870== Command: ./testcase tc8
==870== 
==870== Conditional jump or move depends on uninitialised value(s)
==870==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==870==    by 0x10981B: unallocate_request (server.c:160)
==870==    by 0x10AB14: run_test (testcase.c:90)
==870==    by 0x10AF35: method3 (testcase.c:182)
==870==    by 0x10B35C: main (testcase.c:334)
==870== 
==870== Conditional jump or move depends on uninitialised value(s)
==870==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==870==    by 0x10982E: unallocate_request (server.c:161)
==870==    by 0x10AB14: run_test (testcase.c:90)
==870==    by 0x10AF35: method3 (testcase.c:182)
==870==    by 0x10B35C: main (testcase.c:334)
==870== 
==870== Conditional jump or move depends on uninitialised value(s)
==870==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==870==    by 0x109841: unallocate_request (server.c:162)
==870==    by 0x10AB14: run_test (testcase.c:90)
==870==    by 0x10AF35: method3 (testcase.c:182)
==870==    by 0x10B35C: main (testcase.c:334)
==870== 
==870== Conditional jump or move depends on uninitialised value(s)
==870==    at 0x10989E: unallocate_request (server.c:167)
==870==    by 0x10AB14: run_test (testcase.c:90)
==870==    by 0x10AF35: method3 (testcase.c:182)
==870==    by 0x10B35C: main (testcase.c:334)
==870== 
==870== 
==870== HEAP SUMMARY:
==870==     in use at exit: 0 bytes in 0 blocks
==870==   total heap usage: 3 allocs, 3 frees, 301 bytes allocated
==870== 
==870== All heap blocks were freed -- no leaks are possible
==870== 
==870== Use --track-origins=yes to see where uninitialised values come from
==870== For lists of detected and suppressed errors, rerun with: -s
==870== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc9
\n------------------------\n\n\n
==873== Memcheck, a memory error detector
==873== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==873== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==873== Command: ./testcase tc9
==873== 
==873== 
==873== HEAP SUMMARY:
==873==     in use at exit: 0 bytes in 0 blocks
==873==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==873== 
==873== All heap blocks were freed -- no leaks are possible
==873== 
==873== For lists of detected and suppressed errors, rerun with: -s
==873== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc10
\n------------------------\n\n\n
==876== Memcheck, a memory error detector
==876== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==876== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==876== Command: ./testcase tc10
==876== 
==876== 
==876== HEAP SUMMARY:
==876==     in use at exit: 0 bytes in 0 blocks
==876==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==876== 
==876== All heap blocks were freed -- no leaks are possible
==876== 
==876== For lists of detected and suppressed errors, rerun with: -s
==876== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc11
\n------------------------\n\n\n
==879== Memcheck, a memory error detector
==879== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==879== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==879== Command: ./testcase tc11
==879== 
==879== 
==879== HEAP SUMMARY:
==879==     in use at exit: 0 bytes in 0 blocks
==879==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==879== 
==879== All heap blocks were freed -- no leaks are possible
==879== 
==879== For lists of detected and suppressed errors, rerun with: -s
==879== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc12
\n------------------------\n\n\n
==882== Memcheck, a memory error detector
==882== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==882== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==882== Command: ./testcase tc12
==882== 
==882== 
==882== HEAP SUMMARY:
==882==     in use at exit: 0 bytes in 0 blocks
==882==   total heap usage: 7 allocs, 7 frees, 1,346 bytes allocated
==882== 
==882== All heap blocks were freed -- no leaks are possible
==882== 
==882== For lists of detected and suppressed errors, rerun with: -s
==882== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc13
\n------------------------\n\n\n
==885== Memcheck, a memory error detector
==885== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==885== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==885== Command: ./testcase tc13
==885== 
==885== 
==885== HEAP SUMMARY:
==885==     in use at exit: 0 bytes in 0 blocks
==885==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==885== 
==885== All heap blocks were freed -- no leaks are possible
==885== 
==885== For lists of detected and suppressed errors, rerun with: -s
==885== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc1
\n------------------------\n\n\n
==890== Memcheck, a memory error detector
==890== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==890== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==890== Command: ./testcase tc1
==890== 
==890== 
==890== HEAP SUMMARY:
==890==     in use at exit: 0 bytes in 0 blocks
==890==   total heap usage: 7 allocs, 7 frees, 864 bytes allocated
==890== 
==890== All heap blocks were freed -- no leaks are possible
==890== 
==890== For lists of detected and suppressed errors, rerun with: -s
==890== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc2
\n------------------------\n\n\n
==893== Memcheck, a memory error detector
==893== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==893== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==893== Command: ./testcase tc2
==893== 
==893== 
==893== HEAP SUMMARY:
==893==     in use at exit: 0 bytes in 0 blocks
==893==   total heap usage: 9 allocs, 9 frees, 1,946 bytes allocated
==893== 
==893== All heap blocks were freed -- no leaks are possible
==893== 
==893== For lists of detected and suppressed errors, rerun with: -s
==893== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc3
\n------------------------\n\n\n
==896== Memcheck, a memory error detector
==896== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==896== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==896== Command: ./testcase tc3
==896== 
==896== Use of uninitialised value of size 8
==896==    at 0x10A325: create_request (server.c:419)
==896==    by 0x10AAA5: run_test (testcase.c:77)
==896==    by 0x10ACD1: get3 (testcase.c:138)
==896==    by 0x10B35C: main (testcase.c:334)
==896== 
==896== Invalid read of size 1
==896==    at 0x10A325: create_request (server.c:419)
==896==    by 0x10AAA5: run_test (testcase.c:77)
==896==    by 0x10ACD1: get3 (testcase.c:138)
==896==    by 0x10B35C: main (testcase.c:334)
==896==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==896== 
==896== 
==896== Process terminating with default action of signal 11 (SIGSEGV)
==896==  Access not within mapped region at address 0x0
==896==    at 0x10A325: create_request (server.c:419)
==896==    by 0x10AAA5: run_test (testcase.c:77)
==896==    by 0x10ACD1: get3 (testcase.c:138)
==896==    by 0x10B35C: main (testcase.c:334)
==896==  If you believe this happened as a result of a stack
==896==  overflow in your program's main thread (unlikely but
==896==  possible), you can try to increase the size of the
==896==  main thread stack using the --main-stacksize= flag.
==896==  The main thread stack size used in this run was 8388608.
==896== 
==896== HEAP SUMMARY:
==896==     in use at exit: 320 bytes in 5 blocks
==896==   total heap usage: 5 allocs, 0 frees, 320 bytes allocated
==896== 
==896== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==896==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==896==    by 0x109AFB: create_request (server.c:286)
==896==    by 0x10AAA5: run_test (testcase.c:77)
==896==    by 0x10ACD1: get3 (testcase.c:138)
==896==    by 0x10B35C: main (testcase.c:334)
==896== 
==896== 10 bytes in 1 blocks are still reachable in loss record 2 of 5
==896==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==896==    by 0x109DB1: create_request (server.c:342)
==896==    by 0x10AAA5: run_test (testcase.c:77)
==896==    by 0x10ACD1: get3 (testcase.c:138)
==896==    by 0x10B35C: main (testcase.c:334)
==896== 
==896== 10 bytes in 1 blocks are still reachable in loss record 3 of 5
==896==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==896==    by 0x109DEA: create_request (server.c:344)
==896==    by 0x10AAA5: run_test (testcase.c:77)
==896==    by 0x10ACD1: get3 (testcase.c:138)
==896==    by 0x10B35C: main (testcase.c:334)
==896== 
==896== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==896==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==896==    by 0x109A95: create_request (server.c:277)
==896==    by 0x10AAA5: run_test (testcase.c:77)
==896==    by 0x10ACD1: get3 (testcase.c:138)
==896==    by 0x10B35C: main (testcase.c:334)
==896== 
==896== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==896==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==896==    by 0x10AA7D: run_test (testcase.c:73)
==896==    by 0x10ACD1: get3 (testcase.c:138)
==896==    by 0x10B35C: main (testcase.c:334)
==896== 
==896== LEAK SUMMARY:
==896==    definitely lost: 0 bytes in 0 blocks
==896==    indirectly lost: 0 bytes in 0 blocks
==896==      possibly lost: 0 bytes in 0 blocks
==896==    still reachable: 320 bytes in 5 blocks
==896==         suppressed: 0 bytes in 0 blocks
==896== 
==896== Use --track-origins=yes to see where uninitialised values come from
==896== For lists of detected and suppressed errors, rerun with: -s
==896== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc4
\n------------------------\n\n\n
==899== Memcheck, a memory error detector
==899== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==899== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==899== Command: ./testcase tc4
==899== 
==899== 
==899== HEAP SUMMARY:
==899==     in use at exit: 0 bytes in 0 blocks
==899==   total heap usage: 7 allocs, 7 frees, 1,348 bytes allocated
==899== 
==899== All heap blocks were freed -- no leaks are possible
==899== 
==899== For lists of detected and suppressed errors, rerun with: -s
==899== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc5
\n------------------------\n\n\n
==902== Memcheck, a memory error detector
==902== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==902== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==902== Command: ./testcase tc5
==902== 
==902== Invalid read of size 1
==902==    at 0x109E3E: create_request (server.c:352)
==902==    by 0x10AAA5: run_test (testcase.c:77)
==902==    by 0x10AD6D: get5 (testcase.c:148)
==902==    by 0x10B35C: main (testcase.c:334)
==902==  Address 0x4a78140 is 0 bytes after a block of size 256 alloc'd
==902==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==902==    by 0x10AA7D: run_test (testcase.c:73)
==902==    by 0x10AD6D: get5 (testcase.c:148)
==902==    by 0x10B35C: main (testcase.c:334)
==902== 
==902== Conditional jump or move depends on uninitialised value(s)
==902==    at 0x109E43: create_request (server.c:352)
==902==    by 0x10AAA5: run_test (testcase.c:77)
==902==    by 0x10AD6D: get5 (testcase.c:148)
==902==    by 0x10B35C: main (testcase.c:334)
==902== 
==902== Use of uninitialised value of size 8
==902==    at 0x10A325: create_request (server.c:419)
==902==    by 0x10AAA5: run_test (testcase.c:77)
==902==    by 0x10AD6D: get5 (testcase.c:148)
==902==    by 0x10B35C: main (testcase.c:334)
==902== 
==902== Invalid read of size 1
==902==    at 0x10A325: create_request (server.c:419)
==902==    by 0x10AAA5: run_test (testcase.c:77)
==902==    by 0x10AD6D: get5 (testcase.c:148)
==902==    by 0x10B35C: main (testcase.c:334)
==902==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==902== 
==902== 
==902== Process terminating with default action of signal 11 (SIGSEGV)
==902==  Access not within mapped region at address 0x0
==902==    at 0x10A325: create_request (server.c:419)
==902==    by 0x10AAA5: run_test (testcase.c:77)
==902==    by 0x10AD6D: get5 (testcase.c:148)
==902==    by 0x10B35C: main (testcase.c:334)
==902==  If you believe this happened as a result of a stack
==902==  overflow in your program's main thread (unlikely but
==902==  possible), you can try to increase the size of the
==902==  main thread stack using the --main-stacksize= flag.
==902==  The main thread stack size used in this run was 8388608.
==902== 
==902== HEAP SUMMARY:
==902==     in use at exit: 326 bytes in 5 blocks
==902==   total heap usage: 5 allocs, 0 frees, 326 bytes allocated
==902== 
==902== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==902==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==902==    by 0x109AFB: create_request (server.c:286)
==902==    by 0x10AAA5: run_test (testcase.c:77)
==902==    by 0x10AD6D: get5 (testcase.c:148)
==902==    by 0x10B35C: main (testcase.c:334)
==902== 
==902== 13 bytes in 1 blocks are still reachable in loss record 2 of 5
==902==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==902==    by 0x109DB1: create_request (server.c:342)
==902==    by 0x10AAA5: run_test (testcase.c:77)
==902==    by 0x10AD6D: get5 (testcase.c:148)
==902==    by 0x10B35C: main (testcase.c:334)
==902== 
==902== 13 bytes in 1 blocks are still reachable in loss record 3 of 5
==902==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==902==    by 0x109DEA: create_request (server.c:344)
==902==    by 0x10AAA5: run_test (testcase.c:77)
==902==    by 0x10AD6D: get5 (testcase.c:148)
==902==    by 0x10B35C: main (testcase.c:334)
==902== 
==902== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==902==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==902==    by 0x109A95: create_request (server.c:277)
==902==    by 0x10AAA5: run_test (testcase.c:77)
==902==    by 0x10AD6D: get5 (testcase.c:148)
==902==    by 0x10B35C: main (testcase.c:334)
==902== 
==902== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==902==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==902==    by 0x10AA7D: run_test (testcase.c:73)
==902==    by 0x10AD6D: get5 (testcase.c:148)
==902==    by 0x10B35C: main (testcase.c:334)
==902== 
==902== LEAK SUMMARY:
==902==    definitely lost: 0 bytes in 0 blocks
==902==    indirectly lost: 0 bytes in 0 blocks
==902==      possibly lost: 0 bytes in 0 blocks
==902==    still reachable: 326 bytes in 5 blocks
==902==         suppressed: 0 bytes in 0 blocks
==902== 
==902== Use --track-origins=yes to see where uninitialised values come from
==902== For lists of detected and suppressed errors, rerun with: -s
==902== ERROR SUMMARY: 230 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc6
\n------------------------\n\n\n
==905== Memcheck, a memory error detector
==905== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==905== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==905== Command: ./testcase tc6
==905== 
==905== Conditional jump or move depends on uninitialised value(s)
==905==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==905==    by 0x10981B: unallocate_request (server.c:160)
==905==    by 0x10AB14: run_test (testcase.c:90)
==905==    by 0x10AE16: method1 (testcase.c:162)
==905==    by 0x10B35C: main (testcase.c:334)
==905== 
==905== Conditional jump or move depends on uninitialised value(s)
==905==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==905==    by 0x10982E: unallocate_request (server.c:161)
==905==    by 0x10AB14: run_test (testcase.c:90)
==905==    by 0x10AE16: method1 (testcase.c:162)
==905==    by 0x10B35C: main (testcase.c:334)
==905== 
==905== Conditional jump or move depends on uninitialised value(s)
==905==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==905==    by 0x109841: unallocate_request (server.c:162)
==905==    by 0x10AB14: run_test (testcase.c:90)
==905==    by 0x10AE16: method1 (testcase.c:162)
==905==    by 0x10B35C: main (testcase.c:334)
==905== 
==905== Conditional jump or move depends on uninitialised value(s)
==905==    at 0x10989E: unallocate_request (server.c:167)
==905==    by 0x10AB14: run_test (testcase.c:90)
==905==    by 0x10AE16: method1 (testcase.c:162)
==905==    by 0x10B35C: main (testcase.c:334)
==905== 
==905== 
==905== HEAP SUMMARY:
==905==     in use at exit: 0 bytes in 0 blocks
==905==   total heap usage: 4 allocs, 4 frees, 1,324 bytes allocated
==905== 
==905== All heap blocks were freed -- no leaks are possible
==905== 
==905== Use --track-origins=yes to see where uninitialised values come from
==905== For lists of detected and suppressed errors, rerun with: -s
==905== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc7
\n------------------------\n\n\n
==908== Memcheck, a memory error detector
==908== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==908== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==908== Command: ./testcase tc7
==908== 
==908== Conditional jump or move depends on uninitialised value(s)
==908==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==908==    by 0x10981B: unallocate_request (server.c:160)
==908==    by 0x10AB14: run_test (testcase.c:90)
==908==    by 0x10AED3: method2 (testcase.c:172)
==908==    by 0x10B35C: main (testcase.c:334)
==908== 
==908== Conditional jump or move depends on uninitialised value(s)
==908==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==908==    by 0x10982E: unallocate_request (server.c:161)
==908==    by 0x10AB14: run_test (testcase.c:90)
==908==    by 0x10AED3: method2 (testcase.c:172)
==908==    by 0x10B35C: main (testcase.c:334)
==908== 
==908== Conditional jump or move depends on uninitialised value(s)
==908==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==908==    by 0x109841: unallocate_request (server.c:162)
==908==    by 0x10AB14: run_test (testcase.c:90)
==908==    by 0x10AED3: method2 (testcase.c:172)
==908==    by 0x10B35C: main (testcase.c:334)
==908== 
==908== Conditional jump or move depends on uninitialised value(s)
==908==    at 0x10989E: unallocate_request (server.c:167)
==908==    by 0x10AB14: run_test (testcase.c:90)
==908==    by 0x10AED3: method2 (testcase.c:172)
==908==    by 0x10B35C: main (testcase.c:334)
==908== 
==908== 
==908== HEAP SUMMARY:
==908==     in use at exit: 0 bytes in 0 blocks
==908==   total heap usage: 4 allocs, 4 frees, 1,325 bytes allocated
==908== 
==908== All heap blocks were freed -- no leaks are possible
==908== 
==908== Use --track-origins=yes to see where uninitialised values come from
==908== For lists of detected and suppressed errors, rerun with: -s
==908== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc8
\n------------------------\n\n\n
==911== Memcheck, a memory error detector
==911== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==911== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==911== Command: ./testcase tc8
==911== 
==911== Conditional jump or move depends on uninitialised value(s)
==911==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==911==    by 0x10981B: unallocate_request (server.c:160)
==911==    by 0x10AB14: run_test (testcase.c:90)
==911==    by 0x10AF35: method3 (testcase.c:182)
==911==    by 0x10B35C: main (testcase.c:334)
==911== 
==911== Conditional jump or move depends on uninitialised value(s)
==911==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==911==    by 0x10982E: unallocate_request (server.c:161)
==911==    by 0x10AB14: run_test (testcase.c:90)
==911==    by 0x10AF35: method3 (testcase.c:182)
==911==    by 0x10B35C: main (testcase.c:334)
==911== 
==911== Conditional jump or move depends on uninitialised value(s)
==911==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==911==    by 0x109841: unallocate_request (server.c:162)
==911==    by 0x10AB14: run_test (testcase.c:90)
==911==    by 0x10AF35: method3 (testcase.c:182)
==911==    by 0x10B35C: main (testcase.c:334)
==911== 
==911== Conditional jump or move depends on uninitialised value(s)
==911==    at 0x10989E: unallocate_request (server.c:167)
==911==    by 0x10AB14: run_test (testcase.c:90)
==911==    by 0x10AF35: method3 (testcase.c:182)
==911==    by 0x10B35C: main (testcase.c:334)
==911== 
==911== 
==911== HEAP SUMMARY:
==911==     in use at exit: 0 bytes in 0 blocks
==911==   total heap usage: 3 allocs, 3 frees, 301 bytes allocated
==911== 
==911== All heap blocks were freed -- no leaks are possible
==911== 
==911== Use --track-origins=yes to see where uninitialised values come from
==911== For lists of detected and suppressed errors, rerun with: -s
==911== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc9
\n------------------------\n\n\n
==914== Memcheck, a memory error detector
==914== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==914== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==914== Command: ./testcase tc9
==914== 
==914== 
==914== HEAP SUMMARY:
==914==     in use at exit: 0 bytes in 0 blocks
==914==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==914== 
==914== All heap blocks were freed -- no leaks are possible
==914== 
==914== For lists of detected and suppressed errors, rerun with: -s
==914== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc10
\n------------------------\n\n\n
==917== Memcheck, a memory error detector
==917== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==917== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==917== Command: ./testcase tc10
==917== 
==917== 
==917== HEAP SUMMARY:
==917==     in use at exit: 0 bytes in 0 blocks
==917==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==917== 
==917== All heap blocks were freed -- no leaks are possible
==917== 
==917== For lists of detected and suppressed errors, rerun with: -s
==917== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc11
\n------------------------\n\n\n
==920== Memcheck, a memory error detector
==920== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==920== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==920== Command: ./testcase tc11
==920== 
==920== 
==920== HEAP SUMMARY:
==920==     in use at exit: 0 bytes in 0 blocks
==920==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==920== 
==920== All heap blocks were freed -- no leaks are possible
==920== 
==920== For lists of detected and suppressed errors, rerun with: -s
==920== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc12
\n------------------------\n\n\n
==923== Memcheck, a memory error detector
==923== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==923== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==923== Command: ./testcase tc12
==923== 
==923== 
==923== HEAP SUMMARY:
==923==     in use at exit: 0 bytes in 0 blocks
==923==   total heap usage: 7 allocs, 7 frees, 1,346 bytes allocated
==923== 
==923== All heap blocks were freed -- no leaks are possible
==923== 
==923== For lists of detected and suppressed errors, rerun with: -s
==923== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc13
\n------------------------\n\n\n
==926== Memcheck, a memory error detector
==926== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==926== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==926== Command: ./testcase tc13
==926== 
==926== 
==926== HEAP SUMMARY:
==926==     in use at exit: 0 bytes in 0 blocks
==926==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==926== 
==926== All heap blocks were freed -- no leaks are possible
==926== 
==926== For lists of detected and suppressed errors, rerun with: -s
==926== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc1
\n------------------------\n\n\n
==931== Memcheck, a memory error detector
==931== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==931== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==931== Command: ./testcase tc1
==931== 
==931== 
==931== HEAP SUMMARY:
==931==     in use at exit: 0 bytes in 0 blocks
==931==   total heap usage: 7 allocs, 7 frees, 864 bytes allocated
==931== 
==931== All heap blocks were freed -- no leaks are possible
==931== 
==931== For lists of detected and suppressed errors, rerun with: -s
==931== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc2
\n------------------------\n\n\n
==934== Memcheck, a memory error detector
==934== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==934== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==934== Command: ./testcase tc2
==934== 
==934== 
==934== HEAP SUMMARY:
==934==     in use at exit: 0 bytes in 0 blocks
==934==   total heap usage: 9 allocs, 9 frees, 1,946 bytes allocated
==934== 
==934== All heap blocks were freed -- no leaks are possible
==934== 
==934== For lists of detected and suppressed errors, rerun with: -s
==934== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc3
\n------------------------\n\n\n
==937== Memcheck, a memory error detector
==937== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==937== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==937== Command: ./testcase tc3
==937== 
==937== Use of uninitialised value of size 8
==937==    at 0x10A325: create_request (server.c:419)
==937==    by 0x10AAA5: run_test (testcase.c:77)
==937==    by 0x10ACD1: get3 (testcase.c:138)
==937==    by 0x10B35C: main (testcase.c:334)
==937== 
==937== Invalid read of size 1
==937==    at 0x10A325: create_request (server.c:419)
==937==    by 0x10AAA5: run_test (testcase.c:77)
==937==    by 0x10ACD1: get3 (testcase.c:138)
==937==    by 0x10B35C: main (testcase.c:334)
==937==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==937== 
==937== 
==937== Process terminating with default action of signal 11 (SIGSEGV)
==937==  Access not within mapped region at address 0x0
==937==    at 0x10A325: create_request (server.c:419)
==937==    by 0x10AAA5: run_test (testcase.c:77)
==937==    by 0x10ACD1: get3 (testcase.c:138)
==937==    by 0x10B35C: main (testcase.c:334)
==937==  If you believe this happened as a result of a stack
==937==  overflow in your program's main thread (unlikely but
==937==  possible), you can try to increase the size of the
==937==  main thread stack using the --main-stacksize= flag.
==937==  The main thread stack size used in this run was 8388608.
==937== 
==937== HEAP SUMMARY:
==937==     in use at exit: 320 bytes in 5 blocks
==937==   total heap usage: 5 allocs, 0 frees, 320 bytes allocated
==937== 
==937== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==937==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==937==    by 0x109AFB: create_request (server.c:286)
==937==    by 0x10AAA5: run_test (testcase.c:77)
==937==    by 0x10ACD1: get3 (testcase.c:138)
==937==    by 0x10B35C: main (testcase.c:334)
==937== 
==937== 10 bytes in 1 blocks are still reachable in loss record 2 of 5
==937==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==937==    by 0x109DB1: create_request (server.c:342)
==937==    by 0x10AAA5: run_test (testcase.c:77)
==937==    by 0x10ACD1: get3 (testcase.c:138)
==937==    by 0x10B35C: main (testcase.c:334)
==937== 
==937== 10 bytes in 1 blocks are still reachable in loss record 3 of 5
==937==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==937==    by 0x109DEA: create_request (server.c:344)
==937==    by 0x10AAA5: run_test (testcase.c:77)
==937==    by 0x10ACD1: get3 (testcase.c:138)
==937==    by 0x10B35C: main (testcase.c:334)
==937== 
==937== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==937==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==937==    by 0x109A95: create_request (server.c:277)
==937==    by 0x10AAA5: run_test (testcase.c:77)
==937==    by 0x10ACD1: get3 (testcase.c:138)
==937==    by 0x10B35C: main (testcase.c:334)
==937== 
==937== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==937==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==937==    by 0x10AA7D: run_test (testcase.c:73)
==937==    by 0x10ACD1: get3 (testcase.c:138)
==937==    by 0x10B35C: main (testcase.c:334)
==937== 
==937== LEAK SUMMARY:
==937==    definitely lost: 0 bytes in 0 blocks
==937==    indirectly lost: 0 bytes in 0 blocks
==937==      possibly lost: 0 bytes in 0 blocks
==937==    still reachable: 320 bytes in 5 blocks
==937==         suppressed: 0 bytes in 0 blocks
==937== 
==937== Use --track-origins=yes to see where uninitialised values come from
==937== For lists of detected and suppressed errors, rerun with: -s
==937== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc4
\n------------------------\n\n\n
==940== Memcheck, a memory error detector
==940== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==940== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==940== Command: ./testcase tc4
==940== 
==940== 
==940== HEAP SUMMARY:
==940==     in use at exit: 0 bytes in 0 blocks
==940==   total heap usage: 7 allocs, 7 frees, 1,348 bytes allocated
==940== 
==940== All heap blocks were freed -- no leaks are possible
==940== 
==940== For lists of detected and suppressed errors, rerun with: -s
==940== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc5
\n------------------------\n\n\n
==943== Memcheck, a memory error detector
==943== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==943== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==943== Command: ./testcase tc5
==943== 
==943== Invalid read of size 1
==943==    at 0x109E3E: create_request (server.c:352)
==943==    by 0x10AAA5: run_test (testcase.c:77)
==943==    by 0x10AD6D: get5 (testcase.c:148)
==943==    by 0x10B35C: main (testcase.c:334)
==943==  Address 0x4a78140 is 0 bytes after a block of size 256 alloc'd
==943==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==943==    by 0x10AA7D: run_test (testcase.c:73)
==943==    by 0x10AD6D: get5 (testcase.c:148)
==943==    by 0x10B35C: main (testcase.c:334)
==943== 
==943== Conditional jump or move depends on uninitialised value(s)
==943==    at 0x109E43: create_request (server.c:352)
==943==    by 0x10AAA5: run_test (testcase.c:77)
==943==    by 0x10AD6D: get5 (testcase.c:148)
==943==    by 0x10B35C: main (testcase.c:334)
==943== 
==943== Use of uninitialised value of size 8
==943==    at 0x10A325: create_request (server.c:419)
==943==    by 0x10AAA5: run_test (testcase.c:77)
==943==    by 0x10AD6D: get5 (testcase.c:148)
==943==    by 0x10B35C: main (testcase.c:334)
==943== 
==943== Invalid read of size 1
==943==    at 0x10A325: create_request (server.c:419)
==943==    by 0x10AAA5: run_test (testcase.c:77)
==943==    by 0x10AD6D: get5 (testcase.c:148)
==943==    by 0x10B35C: main (testcase.c:334)
==943==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==943== 
==943== 
==943== Process terminating with default action of signal 11 (SIGSEGV)
==943==  Access not within mapped region at address 0x0
==943==    at 0x10A325: create_request (server.c:419)
==943==    by 0x10AAA5: run_test (testcase.c:77)
==943==    by 0x10AD6D: get5 (testcase.c:148)
==943==    by 0x10B35C: main (testcase.c:334)
==943==  If you believe this happened as a result of a stack
==943==  overflow in your program's main thread (unlikely but
==943==  possible), you can try to increase the size of the
==943==  main thread stack using the --main-stacksize= flag.
==943==  The main thread stack size used in this run was 8388608.
==943== 
==943== HEAP SUMMARY:
==943==     in use at exit: 326 bytes in 5 blocks
==943==   total heap usage: 5 allocs, 0 frees, 326 bytes allocated
==943== 
==943== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==943==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==943==    by 0x109AFB: create_request (server.c:286)
==943==    by 0x10AAA5: run_test (testcase.c:77)
==943==    by 0x10AD6D: get5 (testcase.c:148)
==943==    by 0x10B35C: main (testcase.c:334)
==943== 
==943== 13 bytes in 1 blocks are still reachable in loss record 2 of 5
==943==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==943==    by 0x109DB1: create_request (server.c:342)
==943==    by 0x10AAA5: run_test (testcase.c:77)
==943==    by 0x10AD6D: get5 (testcase.c:148)
==943==    by 0x10B35C: main (testcase.c:334)
==943== 
==943== 13 bytes in 1 blocks are still reachable in loss record 3 of 5
==943==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==943==    by 0x109DEA: create_request (server.c:344)
==943==    by 0x10AAA5: run_test (testcase.c:77)
==943==    by 0x10AD6D: get5 (testcase.c:148)
==943==    by 0x10B35C: main (testcase.c:334)
==943== 
==943== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==943==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==943==    by 0x109A95: create_request (server.c:277)
==943==    by 0x10AAA5: run_test (testcase.c:77)
==943==    by 0x10AD6D: get5 (testcase.c:148)
==943==    by 0x10B35C: main (testcase.c:334)
==943== 
==943== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==943==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==943==    by 0x10AA7D: run_test (testcase.c:73)
==943==    by 0x10AD6D: get5 (testcase.c:148)
==943==    by 0x10B35C: main (testcase.c:334)
==943== 
==943== LEAK SUMMARY:
==943==    definitely lost: 0 bytes in 0 blocks
==943==    indirectly lost: 0 bytes in 0 blocks
==943==      possibly lost: 0 bytes in 0 blocks
==943==    still reachable: 326 bytes in 5 blocks
==943==         suppressed: 0 bytes in 0 blocks
==943== 
==943== Use --track-origins=yes to see where uninitialised values come from
==943== For lists of detected and suppressed errors, rerun with: -s
==943== ERROR SUMMARY: 230 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc6
\n------------------------\n\n\n
==946== Memcheck, a memory error detector
==946== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==946== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==946== Command: ./testcase tc6
==946== 
==946== Conditional jump or move depends on uninitialised value(s)
==946==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==946==    by 0x10981B: unallocate_request (server.c:160)
==946==    by 0x10AB14: run_test (testcase.c:90)
==946==    by 0x10AE16: method1 (testcase.c:162)
==946==    by 0x10B35C: main (testcase.c:334)
==946== 
==946== Conditional jump or move depends on uninitialised value(s)
==946==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==946==    by 0x10982E: unallocate_request (server.c:161)
==946==    by 0x10AB14: run_test (testcase.c:90)
==946==    by 0x10AE16: method1 (testcase.c:162)
==946==    by 0x10B35C: main (testcase.c:334)
==946== 
==946== Conditional jump or move depends on uninitialised value(s)
==946==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==946==    by 0x109841: unallocate_request (server.c:162)
==946==    by 0x10AB14: run_test (testcase.c:90)
==946==    by 0x10AE16: method1 (testcase.c:162)
==946==    by 0x10B35C: main (testcase.c:334)
==946== 
==946== Conditional jump or move depends on uninitialised value(s)
==946==    at 0x10989E: unallocate_request (server.c:167)
==946==    by 0x10AB14: run_test (testcase.c:90)
==946==    by 0x10AE16: method1 (testcase.c:162)
==946==    by 0x10B35C: main (testcase.c:334)
==946== 
==946== 
==946== HEAP SUMMARY:
==946==     in use at exit: 0 bytes in 0 blocks
==946==   total heap usage: 4 allocs, 4 frees, 1,324 bytes allocated
==946== 
==946== All heap blocks were freed -- no leaks are possible
==946== 
==946== Use --track-origins=yes to see where uninitialised values come from
==946== For lists of detected and suppressed errors, rerun with: -s
==946== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc7
\n------------------------\n\n\n
==949== Memcheck, a memory error detector
==949== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==949== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==949== Command: ./testcase tc7
==949== 
==949== Conditional jump or move depends on uninitialised value(s)
==949==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==949==    by 0x10981B: unallocate_request (server.c:160)
==949==    by 0x10AB14: run_test (testcase.c:90)
==949==    by 0x10AED3: method2 (testcase.c:172)
==949==    by 0x10B35C: main (testcase.c:334)
==949== 
==949== Conditional jump or move depends on uninitialised value(s)
==949==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==949==    by 0x10982E: unallocate_request (server.c:161)
==949==    by 0x10AB14: run_test (testcase.c:90)
==949==    by 0x10AED3: method2 (testcase.c:172)
==949==    by 0x10B35C: main (testcase.c:334)
==949== 
==949== Conditional jump or move depends on uninitialised value(s)
==949==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==949==    by 0x109841: unallocate_request (server.c:162)
==949==    by 0x10AB14: run_test (testcase.c:90)
==949==    by 0x10AED3: method2 (testcase.c:172)
==949==    by 0x10B35C: main (testcase.c:334)
==949== 
==949== Conditional jump or move depends on uninitialised value(s)
==949==    at 0x10989E: unallocate_request (server.c:167)
==949==    by 0x10AB14: run_test (testcase.c:90)
==949==    by 0x10AED3: method2 (testcase.c:172)
==949==    by 0x10B35C: main (testcase.c:334)
==949== 
==949== 
==949== HEAP SUMMARY:
==949==     in use at exit: 0 bytes in 0 blocks
==949==   total heap usage: 4 allocs, 4 frees, 1,325 bytes allocated
==949== 
==949== All heap blocks were freed -- no leaks are possible
==949== 
==949== Use --track-origins=yes to see where uninitialised values come from
==949== For lists of detected and suppressed errors, rerun with: -s
==949== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc8
\n------------------------\n\n\n
==952== Memcheck, a memory error detector
==952== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==952== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==952== Command: ./testcase tc8
==952== 
==952== Conditional jump or move depends on uninitialised value(s)
==952==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==952==    by 0x10981B: unallocate_request (server.c:160)
==952==    by 0x10AB14: run_test (testcase.c:90)
==952==    by 0x10AF35: method3 (testcase.c:182)
==952==    by 0x10B35C: main (testcase.c:334)
==952== 
==952== Conditional jump or move depends on uninitialised value(s)
==952==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==952==    by 0x10982E: unallocate_request (server.c:161)
==952==    by 0x10AB14: run_test (testcase.c:90)
==952==    by 0x10AF35: method3 (testcase.c:182)
==952==    by 0x10B35C: main (testcase.c:334)
==952== 
==952== Conditional jump or move depends on uninitialised value(s)
==952==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==952==    by 0x109841: unallocate_request (server.c:162)
==952==    by 0x10AB14: run_test (testcase.c:90)
==952==    by 0x10AF35: method3 (testcase.c:182)
==952==    by 0x10B35C: main (testcase.c:334)
==952== 
==952== Conditional jump or move depends on uninitialised value(s)
==952==    at 0x10989E: unallocate_request (server.c:167)
==952==    by 0x10AB14: run_test (testcase.c:90)
==952==    by 0x10AF35: method3 (testcase.c:182)
==952==    by 0x10B35C: main (testcase.c:334)
==952== 
==952== 
==952== HEAP SUMMARY:
==952==     in use at exit: 0 bytes in 0 blocks
==952==   total heap usage: 3 allocs, 3 frees, 301 bytes allocated
==952== 
==952== All heap blocks were freed -- no leaks are possible
==952== 
==952== Use --track-origins=yes to see where uninitialised values come from
==952== For lists of detected and suppressed errors, rerun with: -s
==952== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc9
\n------------------------\n\n\n
==955== Memcheck, a memory error detector
==955== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==955== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==955== Command: ./testcase tc9
==955== 
==955== 
==955== HEAP SUMMARY:
==955==     in use at exit: 0 bytes in 0 blocks
==955==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==955== 
==955== All heap blocks were freed -- no leaks are possible
==955== 
==955== For lists of detected and suppressed errors, rerun with: -s
==955== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc10
\n------------------------\n\n\n
==958== Memcheck, a memory error detector
==958== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==958== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==958== Command: ./testcase tc10
==958== 
==958== 
==958== HEAP SUMMARY:
==958==     in use at exit: 0 bytes in 0 blocks
==958==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==958== 
==958== All heap blocks were freed -- no leaks are possible
==958== 
==958== For lists of detected and suppressed errors, rerun with: -s
==958== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc11
\n------------------------\n\n\n
==961== Memcheck, a memory error detector
==961== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==961== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==961== Command: ./testcase tc11
==961== 
==961== 
==961== HEAP SUMMARY:
==961==     in use at exit: 0 bytes in 0 blocks
==961==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==961== 
==961== All heap blocks were freed -- no leaks are possible
==961== 
==961== For lists of detected and suppressed errors, rerun with: -s
==961== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc12
\n------------------------\n\n\n
==964== Memcheck, a memory error detector
==964== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==964== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==964== Command: ./testcase tc12
==964== 
==964== 
==964== HEAP SUMMARY:
==964==     in use at exit: 0 bytes in 0 blocks
==964==   total heap usage: 7 allocs, 7 frees, 1,346 bytes allocated
==964== 
==964== All heap blocks were freed -- no leaks are possible
==964== 
==964== For lists of detected and suppressed errors, rerun with: -s
==964== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc13
\n------------------------\n\n\n
==967== Memcheck, a memory error detector
==967== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==967== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==967== Command: ./testcase tc13
==967== 
==967== 
==967== HEAP SUMMARY:
==967==     in use at exit: 0 bytes in 0 blocks
==967==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==967== 
==967== All heap blocks were freed -- no leaks are possible
==967== 
==967== For lists of detected and suppressed errors, rerun with: -s
==967== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc1
\n------------------------\n\n\n
==985== Memcheck, a memory error detector
==985== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==985== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==985== Command: ./testcase tc1
==985== 
==985== 
==985== HEAP SUMMARY:
==985==     in use at exit: 0 bytes in 0 blocks
==985==   total heap usage: 7 allocs, 7 frees, 864 bytes allocated
==985== 
==985== All heap blocks were freed -- no leaks are possible
==985== 
==985== For lists of detected and suppressed errors, rerun with: -s
==985== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc2
\n------------------------\n\n\n
==988== Memcheck, a memory error detector
==988== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==988== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==988== Command: ./testcase tc2
==988== 
==988== 
==988== HEAP SUMMARY:
==988==     in use at exit: 0 bytes in 0 blocks
==988==   total heap usage: 9 allocs, 9 frees, 1,946 bytes allocated
==988== 
==988== All heap blocks were freed -- no leaks are possible
==988== 
==988== For lists of detected and suppressed errors, rerun with: -s
==988== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc3
\n------------------------\n\n\n
==991== Memcheck, a memory error detector
==991== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==991== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==991== Command: ./testcase tc3
==991== 
==991== Use of uninitialised value of size 8
==991==    at 0x10A325: create_request (server.c:419)
==991==    by 0x10AAA5: run_test (testcase.c:77)
==991==    by 0x10ACD1: get3 (testcase.c:138)
==991==    by 0x10B35C: main (testcase.c:334)
==991== 
==991== Invalid read of size 1
==991==    at 0x10A325: create_request (server.c:419)
==991==    by 0x10AAA5: run_test (testcase.c:77)
==991==    by 0x10ACD1: get3 (testcase.c:138)
==991==    by 0x10B35C: main (testcase.c:334)
==991==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==991== 
==991== 
==991== Process terminating with default action of signal 11 (SIGSEGV)
==991==  Access not within mapped region at address 0x0
==991==    at 0x10A325: create_request (server.c:419)
==991==    by 0x10AAA5: run_test (testcase.c:77)
==991==    by 0x10ACD1: get3 (testcase.c:138)
==991==    by 0x10B35C: main (testcase.c:334)
==991==  If you believe this happened as a result of a stack
==991==  overflow in your program's main thread (unlikely but
==991==  possible), you can try to increase the size of the
==991==  main thread stack using the --main-stacksize= flag.
==991==  The main thread stack size used in this run was 8388608.
==991== 
==991== HEAP SUMMARY:
==991==     in use at exit: 320 bytes in 5 blocks
==991==   total heap usage: 5 allocs, 0 frees, 320 bytes allocated
==991== 
==991== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==991==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==991==    by 0x109AFB: create_request (server.c:286)
==991==    by 0x10AAA5: run_test (testcase.c:77)
==991==    by 0x10ACD1: get3 (testcase.c:138)
==991==    by 0x10B35C: main (testcase.c:334)
==991== 
==991== 10 bytes in 1 blocks are still reachable in loss record 2 of 5
==991==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==991==    by 0x109DB1: create_request (server.c:342)
==991==    by 0x10AAA5: run_test (testcase.c:77)
==991==    by 0x10ACD1: get3 (testcase.c:138)
==991==    by 0x10B35C: main (testcase.c:334)
==991== 
==991== 10 bytes in 1 blocks are still reachable in loss record 3 of 5
==991==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==991==    by 0x109DEA: create_request (server.c:344)
==991==    by 0x10AAA5: run_test (testcase.c:77)
==991==    by 0x10ACD1: get3 (testcase.c:138)
==991==    by 0x10B35C: main (testcase.c:334)
==991== 
==991== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==991==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==991==    by 0x109A95: create_request (server.c:277)
==991==    by 0x10AAA5: run_test (testcase.c:77)
==991==    by 0x10ACD1: get3 (testcase.c:138)
==991==    by 0x10B35C: main (testcase.c:334)
==991== 
==991== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==991==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==991==    by 0x10AA7D: run_test (testcase.c:73)
==991==    by 0x10ACD1: get3 (testcase.c:138)
==991==    by 0x10B35C: main (testcase.c:334)
==991== 
==991== LEAK SUMMARY:
==991==    definitely lost: 0 bytes in 0 blocks
==991==    indirectly lost: 0 bytes in 0 blocks
==991==      possibly lost: 0 bytes in 0 blocks
==991==    still reachable: 320 bytes in 5 blocks
==991==         suppressed: 0 bytes in 0 blocks
==991== 
==991== Use --track-origins=yes to see where uninitialised values come from
==991== For lists of detected and suppressed errors, rerun with: -s
==991== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc4
\n------------------------\n\n\n
==994== Memcheck, a memory error detector
==994== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==994== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==994== Command: ./testcase tc4
==994== 
==994== 
==994== HEAP SUMMARY:
==994==     in use at exit: 0 bytes in 0 blocks
==994==   total heap usage: 7 allocs, 7 frees, 1,348 bytes allocated
==994== 
==994== All heap blocks were freed -- no leaks are possible
==994== 
==994== For lists of detected and suppressed errors, rerun with: -s
==994== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc5
\n------------------------\n\n\n
==997== Memcheck, a memory error detector
==997== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==997== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==997== Command: ./testcase tc5
==997== 
==997== Invalid read of size 1
==997==    at 0x109E3E: create_request (server.c:352)
==997==    by 0x10AAA5: run_test (testcase.c:77)
==997==    by 0x10AD6D: get5 (testcase.c:148)
==997==    by 0x10B35C: main (testcase.c:334)
==997==  Address 0x4a78140 is 0 bytes after a block of size 256 alloc'd
==997==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==997==    by 0x10AA7D: run_test (testcase.c:73)
==997==    by 0x10AD6D: get5 (testcase.c:148)
==997==    by 0x10B35C: main (testcase.c:334)
==997== 
==997== Conditional jump or move depends on uninitialised value(s)
==997==    at 0x109E43: create_request (server.c:352)
==997==    by 0x10AAA5: run_test (testcase.c:77)
==997==    by 0x10AD6D: get5 (testcase.c:148)
==997==    by 0x10B35C: main (testcase.c:334)
==997== 
==997== Use of uninitialised value of size 8
==997==    at 0x10A325: create_request (server.c:419)
==997==    by 0x10AAA5: run_test (testcase.c:77)
==997==    by 0x10AD6D: get5 (testcase.c:148)
==997==    by 0x10B35C: main (testcase.c:334)
==997== 
==997== Invalid read of size 1
==997==    at 0x10A325: create_request (server.c:419)
==997==    by 0x10AAA5: run_test (testcase.c:77)
==997==    by 0x10AD6D: get5 (testcase.c:148)
==997==    by 0x10B35C: main (testcase.c:334)
==997==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==997== 
==997== 
==997== Process terminating with default action of signal 11 (SIGSEGV)
==997==  Access not within mapped region at address 0x0
==997==    at 0x10A325: create_request (server.c:419)
==997==    by 0x10AAA5: run_test (testcase.c:77)
==997==    by 0x10AD6D: get5 (testcase.c:148)
==997==    by 0x10B35C: main (testcase.c:334)
==997==  If you believe this happened as a result of a stack
==997==  overflow in your program's main thread (unlikely but
==997==  possible), you can try to increase the size of the
==997==  main thread stack using the --main-stacksize= flag.
==997==  The main thread stack size used in this run was 8388608.
==997== 
==997== HEAP SUMMARY:
==997==     in use at exit: 326 bytes in 5 blocks
==997==   total heap usage: 5 allocs, 0 frees, 326 bytes allocated
==997== 
==997== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==997==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==997==    by 0x109AFB: create_request (server.c:286)
==997==    by 0x10AAA5: run_test (testcase.c:77)
==997==    by 0x10AD6D: get5 (testcase.c:148)
==997==    by 0x10B35C: main (testcase.c:334)
==997== 
==997== 13 bytes in 1 blocks are still reachable in loss record 2 of 5
==997==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==997==    by 0x109DB1: create_request (server.c:342)
==997==    by 0x10AAA5: run_test (testcase.c:77)
==997==    by 0x10AD6D: get5 (testcase.c:148)
==997==    by 0x10B35C: main (testcase.c:334)
==997== 
==997== 13 bytes in 1 blocks are still reachable in loss record 3 of 5
==997==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==997==    by 0x109DEA: create_request (server.c:344)
==997==    by 0x10AAA5: run_test (testcase.c:77)
==997==    by 0x10AD6D: get5 (testcase.c:148)
==997==    by 0x10B35C: main (testcase.c:334)
==997== 
==997== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==997==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==997==    by 0x109A95: create_request (server.c:277)
==997==    by 0x10AAA5: run_test (testcase.c:77)
==997==    by 0x10AD6D: get5 (testcase.c:148)
==997==    by 0x10B35C: main (testcase.c:334)
==997== 
==997== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==997==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==997==    by 0x10AA7D: run_test (testcase.c:73)
==997==    by 0x10AD6D: get5 (testcase.c:148)
==997==    by 0x10B35C: main (testcase.c:334)
==997== 
==997== LEAK SUMMARY:
==997==    definitely lost: 0 bytes in 0 blocks
==997==    indirectly lost: 0 bytes in 0 blocks
==997==      possibly lost: 0 bytes in 0 blocks
==997==    still reachable: 326 bytes in 5 blocks
==997==         suppressed: 0 bytes in 0 blocks
==997== 
==997== Use --track-origins=yes to see where uninitialised values come from
==997== For lists of detected and suppressed errors, rerun with: -s
==997== ERROR SUMMARY: 230 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc6
\n------------------------\n\n\n
==1000== Memcheck, a memory error detector
==1000== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1000== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1000== Command: ./testcase tc6
==1000== 
==1000== Conditional jump or move depends on uninitialised value(s)
==1000==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1000==    by 0x10981B: unallocate_request (server.c:160)
==1000==    by 0x10AB14: run_test (testcase.c:90)
==1000==    by 0x10AE16: method1 (testcase.c:162)
==1000==    by 0x10B35C: main (testcase.c:334)
==1000== 
==1000== Conditional jump or move depends on uninitialised value(s)
==1000==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1000==    by 0x10982E: unallocate_request (server.c:161)
==1000==    by 0x10AB14: run_test (testcase.c:90)
==1000==    by 0x10AE16: method1 (testcase.c:162)
==1000==    by 0x10B35C: main (testcase.c:334)
==1000== 
==1000== Conditional jump or move depends on uninitialised value(s)
==1000==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1000==    by 0x109841: unallocate_request (server.c:162)
==1000==    by 0x10AB14: run_test (testcase.c:90)
==1000==    by 0x10AE16: method1 (testcase.c:162)
==1000==    by 0x10B35C: main (testcase.c:334)
==1000== 
==1000== Conditional jump or move depends on uninitialised value(s)
==1000==    at 0x10989E: unallocate_request (server.c:167)
==1000==    by 0x10AB14: run_test (testcase.c:90)
==1000==    by 0x10AE16: method1 (testcase.c:162)
==1000==    by 0x10B35C: main (testcase.c:334)
==1000== 
==1000== 
==1000== HEAP SUMMARY:
==1000==     in use at exit: 0 bytes in 0 blocks
==1000==   total heap usage: 4 allocs, 4 frees, 1,324 bytes allocated
==1000== 
==1000== All heap blocks were freed -- no leaks are possible
==1000== 
==1000== Use --track-origins=yes to see where uninitialised values come from
==1000== For lists of detected and suppressed errors, rerun with: -s
==1000== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc7
\n------------------------\n\n\n
==1003== Memcheck, a memory error detector
==1003== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1003== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1003== Command: ./testcase tc7
==1003== 
==1003== Conditional jump or move depends on uninitialised value(s)
==1003==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1003==    by 0x10981B: unallocate_request (server.c:160)
==1003==    by 0x10AB14: run_test (testcase.c:90)
==1003==    by 0x10AED3: method2 (testcase.c:172)
==1003==    by 0x10B35C: main (testcase.c:334)
==1003== 
==1003== Conditional jump or move depends on uninitialised value(s)
==1003==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1003==    by 0x10982E: unallocate_request (server.c:161)
==1003==    by 0x10AB14: run_test (testcase.c:90)
==1003==    by 0x10AED3: method2 (testcase.c:172)
==1003==    by 0x10B35C: main (testcase.c:334)
==1003== 
==1003== Conditional jump or move depends on uninitialised value(s)
==1003==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1003==    by 0x109841: unallocate_request (server.c:162)
==1003==    by 0x10AB14: run_test (testcase.c:90)
==1003==    by 0x10AED3: method2 (testcase.c:172)
==1003==    by 0x10B35C: main (testcase.c:334)
==1003== 
==1003== Conditional jump or move depends on uninitialised value(s)
==1003==    at 0x10989E: unallocate_request (server.c:167)
==1003==    by 0x10AB14: run_test (testcase.c:90)
==1003==    by 0x10AED3: method2 (testcase.c:172)
==1003==    by 0x10B35C: main (testcase.c:334)
==1003== 
==1003== 
==1003== HEAP SUMMARY:
==1003==     in use at exit: 0 bytes in 0 blocks
==1003==   total heap usage: 4 allocs, 4 frees, 1,325 bytes allocated
==1003== 
==1003== All heap blocks were freed -- no leaks are possible
==1003== 
==1003== Use --track-origins=yes to see where uninitialised values come from
==1003== For lists of detected and suppressed errors, rerun with: -s
==1003== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc8
\n------------------------\n\n\n
==1006== Memcheck, a memory error detector
==1006== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1006== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1006== Command: ./testcase tc8
==1006== 
==1006== Conditional jump or move depends on uninitialised value(s)
==1006==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1006==    by 0x10981B: unallocate_request (server.c:160)
==1006==    by 0x10AB14: run_test (testcase.c:90)
==1006==    by 0x10AF35: method3 (testcase.c:182)
==1006==    by 0x10B35C: main (testcase.c:334)
==1006== 
==1006== Conditional jump or move depends on uninitialised value(s)
==1006==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1006==    by 0x10982E: unallocate_request (server.c:161)
==1006==    by 0x10AB14: run_test (testcase.c:90)
==1006==    by 0x10AF35: method3 (testcase.c:182)
==1006==    by 0x10B35C: main (testcase.c:334)
==1006== 
==1006== Conditional jump or move depends on uninitialised value(s)
==1006==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1006==    by 0x109841: unallocate_request (server.c:162)
==1006==    by 0x10AB14: run_test (testcase.c:90)
==1006==    by 0x10AF35: method3 (testcase.c:182)
==1006==    by 0x10B35C: main (testcase.c:334)
==1006== 
==1006== Conditional jump or move depends on uninitialised value(s)
==1006==    at 0x10989E: unallocate_request (server.c:167)
==1006==    by 0x10AB14: run_test (testcase.c:90)
==1006==    by 0x10AF35: method3 (testcase.c:182)
==1006==    by 0x10B35C: main (testcase.c:334)
==1006== 
==1006== 
==1006== HEAP SUMMARY:
==1006==     in use at exit: 0 bytes in 0 blocks
==1006==   total heap usage: 3 allocs, 3 frees, 301 bytes allocated
==1006== 
==1006== All heap blocks were freed -- no leaks are possible
==1006== 
==1006== Use --track-origins=yes to see where uninitialised values come from
==1006== For lists of detected and suppressed errors, rerun with: -s
==1006== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc9
\n------------------------\n\n\n
==1009== Memcheck, a memory error detector
==1009== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1009== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1009== Command: ./testcase tc9
==1009== 
==1009== 
==1009== HEAP SUMMARY:
==1009==     in use at exit: 0 bytes in 0 blocks
==1009==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==1009== 
==1009== All heap blocks were freed -- no leaks are possible
==1009== 
==1009== For lists of detected and suppressed errors, rerun with: -s
==1009== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc10
\n------------------------\n\n\n
==1012== Memcheck, a memory error detector
==1012== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1012== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1012== Command: ./testcase tc10
==1012== 
==1012== 
==1012== HEAP SUMMARY:
==1012==     in use at exit: 0 bytes in 0 blocks
==1012==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==1012== 
==1012== All heap blocks were freed -- no leaks are possible
==1012== 
==1012== For lists of detected and suppressed errors, rerun with: -s
==1012== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc11
\n------------------------\n\n\n
==1015== Memcheck, a memory error detector
==1015== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1015== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1015== Command: ./testcase tc11
==1015== 
==1015== 
==1015== HEAP SUMMARY:
==1015==     in use at exit: 0 bytes in 0 blocks
==1015==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==1015== 
==1015== All heap blocks were freed -- no leaks are possible
==1015== 
==1015== For lists of detected and suppressed errors, rerun with: -s
==1015== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc12
\n------------------------\n\n\n
==1018== Memcheck, a memory error detector
==1018== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1018== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1018== Command: ./testcase tc12
==1018== 
==1018== 
==1018== HEAP SUMMARY:
==1018==     in use at exit: 0 bytes in 0 blocks
==1018==   total heap usage: 7 allocs, 7 frees, 1,346 bytes allocated
==1018== 
==1018== All heap blocks were freed -- no leaks are possible
==1018== 
==1018== For lists of detected and suppressed errors, rerun with: -s
==1018== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc13
\n------------------------\n\n\n
==1021== Memcheck, a memory error detector
==1021== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1021== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1021== Command: ./testcase tc13
==1021== 
==1021== 
==1021== HEAP SUMMARY:
==1021==     in use at exit: 0 bytes in 0 blocks
==1021==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==1021== 
==1021== All heap blocks were freed -- no leaks are possible
==1021== 
==1021== For lists of detected and suppressed errors, rerun with: -s
==1021== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc1
\n------------------------\n\n\n
==1034== Memcheck, a memory error detector
==1034== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1034== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1034== Command: ./testcase tc1
==1034== 
==1034== 
==1034== HEAP SUMMARY:
==1034==     in use at exit: 0 bytes in 0 blocks
==1034==   total heap usage: 7 allocs, 7 frees, 864 bytes allocated
==1034== 
==1034== All heap blocks were freed -- no leaks are possible
==1034== 
==1034== For lists of detected and suppressed errors, rerun with: -s
==1034== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc2
\n------------------------\n\n\n
==1037== Memcheck, a memory error detector
==1037== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1037== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1037== Command: ./testcase tc2
==1037== 
==1037== 
==1037== HEAP SUMMARY:
==1037==     in use at exit: 0 bytes in 0 blocks
==1037==   total heap usage: 9 allocs, 9 frees, 1,946 bytes allocated
==1037== 
==1037== All heap blocks were freed -- no leaks are possible
==1037== 
==1037== For lists of detected and suppressed errors, rerun with: -s
==1037== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc3
\n------------------------\n\n\n
==1040== Memcheck, a memory error detector
==1040== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1040== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1040== Command: ./testcase tc3
==1040== 
==1040== Use of uninitialised value of size 8
==1040==    at 0x10A325: create_request (server.c:419)
==1040==    by 0x10AAA5: run_test (testcase.c:77)
==1040==    by 0x10ACD1: get3 (testcase.c:138)
==1040==    by 0x10B35C: main (testcase.c:334)
==1040== 
==1040== Invalid read of size 1
==1040==    at 0x10A325: create_request (server.c:419)
==1040==    by 0x10AAA5: run_test (testcase.c:77)
==1040==    by 0x10ACD1: get3 (testcase.c:138)
==1040==    by 0x10B35C: main (testcase.c:334)
==1040==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==1040== 
==1040== 
==1040== Process terminating with default action of signal 11 (SIGSEGV)
==1040==  Access not within mapped region at address 0x0
==1040==    at 0x10A325: create_request (server.c:419)
==1040==    by 0x10AAA5: run_test (testcase.c:77)
==1040==    by 0x10ACD1: get3 (testcase.c:138)
==1040==    by 0x10B35C: main (testcase.c:334)
==1040==  If you believe this happened as a result of a stack
==1040==  overflow in your program's main thread (unlikely but
==1040==  possible), you can try to increase the size of the
==1040==  main thread stack using the --main-stacksize= flag.
==1040==  The main thread stack size used in this run was 8388608.
==1040== 
==1040== HEAP SUMMARY:
==1040==     in use at exit: 320 bytes in 5 blocks
==1040==   total heap usage: 5 allocs, 0 frees, 320 bytes allocated
==1040== 
==1040== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==1040==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1040==    by 0x109AFB: create_request (server.c:286)
==1040==    by 0x10AAA5: run_test (testcase.c:77)
==1040==    by 0x10ACD1: get3 (testcase.c:138)
==1040==    by 0x10B35C: main (testcase.c:334)
==1040== 
==1040== 10 bytes in 1 blocks are still reachable in loss record 2 of 5
==1040==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1040==    by 0x109DB1: create_request (server.c:342)
==1040==    by 0x10AAA5: run_test (testcase.c:77)
==1040==    by 0x10ACD1: get3 (testcase.c:138)
==1040==    by 0x10B35C: main (testcase.c:334)
==1040== 
==1040== 10 bytes in 1 blocks are still reachable in loss record 3 of 5
==1040==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1040==    by 0x109DEA: create_request (server.c:344)
==1040==    by 0x10AAA5: run_test (testcase.c:77)
==1040==    by 0x10ACD1: get3 (testcase.c:138)
==1040==    by 0x10B35C: main (testcase.c:334)
==1040== 
==1040== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==1040==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1040==    by 0x109A95: create_request (server.c:277)
==1040==    by 0x10AAA5: run_test (testcase.c:77)
==1040==    by 0x10ACD1: get3 (testcase.c:138)
==1040==    by 0x10B35C: main (testcase.c:334)
==1040== 
==1040== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==1040==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1040==    by 0x10AA7D: run_test (testcase.c:73)
==1040==    by 0x10ACD1: get3 (testcase.c:138)
==1040==    by 0x10B35C: main (testcase.c:334)
==1040== 
==1040== LEAK SUMMARY:
==1040==    definitely lost: 0 bytes in 0 blocks
==1040==    indirectly lost: 0 bytes in 0 blocks
==1040==      possibly lost: 0 bytes in 0 blocks
==1040==    still reachable: 320 bytes in 5 blocks
==1040==         suppressed: 0 bytes in 0 blocks
==1040== 
==1040== Use --track-origins=yes to see where uninitialised values come from
==1040== For lists of detected and suppressed errors, rerun with: -s
==1040== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc4
\n------------------------\n\n\n
==1043== Memcheck, a memory error detector
==1043== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1043== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1043== Command: ./testcase tc4
==1043== 
==1043== 
==1043== HEAP SUMMARY:
==1043==     in use at exit: 0 bytes in 0 blocks
==1043==   total heap usage: 7 allocs, 7 frees, 1,348 bytes allocated
==1043== 
==1043== All heap blocks were freed -- no leaks are possible
==1043== 
==1043== For lists of detected and suppressed errors, rerun with: -s
==1043== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc5
\n------------------------\n\n\n
==1046== Memcheck, a memory error detector
==1046== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1046== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1046== Command: ./testcase tc5
==1046== 
==1046== Invalid read of size 1
==1046==    at 0x109E3E: create_request (server.c:352)
==1046==    by 0x10AAA5: run_test (testcase.c:77)
==1046==    by 0x10AD6D: get5 (testcase.c:148)
==1046==    by 0x10B35C: main (testcase.c:334)
==1046==  Address 0x4a78140 is 0 bytes after a block of size 256 alloc'd
==1046==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1046==    by 0x10AA7D: run_test (testcase.c:73)
==1046==    by 0x10AD6D: get5 (testcase.c:148)
==1046==    by 0x10B35C: main (testcase.c:334)
==1046== 
==1046== Conditional jump or move depends on uninitialised value(s)
==1046==    at 0x109E43: create_request (server.c:352)
==1046==    by 0x10AAA5: run_test (testcase.c:77)
==1046==    by 0x10AD6D: get5 (testcase.c:148)
==1046==    by 0x10B35C: main (testcase.c:334)
==1046== 
==1046== Use of uninitialised value of size 8
==1046==    at 0x10A325: create_request (server.c:419)
==1046==    by 0x10AAA5: run_test (testcase.c:77)
==1046==    by 0x10AD6D: get5 (testcase.c:148)
==1046==    by 0x10B35C: main (testcase.c:334)
==1046== 
==1046== Invalid read of size 1
==1046==    at 0x10A325: create_request (server.c:419)
==1046==    by 0x10AAA5: run_test (testcase.c:77)
==1046==    by 0x10AD6D: get5 (testcase.c:148)
==1046==    by 0x10B35C: main (testcase.c:334)
==1046==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==1046== 
==1046== 
==1046== Process terminating with default action of signal 11 (SIGSEGV)
==1046==  Access not within mapped region at address 0x0
==1046==    at 0x10A325: create_request (server.c:419)
==1046==    by 0x10AAA5: run_test (testcase.c:77)
==1046==    by 0x10AD6D: get5 (testcase.c:148)
==1046==    by 0x10B35C: main (testcase.c:334)
==1046==  If you believe this happened as a result of a stack
==1046==  overflow in your program's main thread (unlikely but
==1046==  possible), you can try to increase the size of the
==1046==  main thread stack using the --main-stacksize= flag.
==1046==  The main thread stack size used in this run was 8388608.
==1046== 
==1046== HEAP SUMMARY:
==1046==     in use at exit: 326 bytes in 5 blocks
==1046==   total heap usage: 5 allocs, 0 frees, 326 bytes allocated
==1046== 
==1046== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==1046==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1046==    by 0x109AFB: create_request (server.c:286)
==1046==    by 0x10AAA5: run_test (testcase.c:77)
==1046==    by 0x10AD6D: get5 (testcase.c:148)
==1046==    by 0x10B35C: main (testcase.c:334)
==1046== 
==1046== 13 bytes in 1 blocks are still reachable in loss record 2 of 5
==1046==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1046==    by 0x109DB1: create_request (server.c:342)
==1046==    by 0x10AAA5: run_test (testcase.c:77)
==1046==    by 0x10AD6D: get5 (testcase.c:148)
==1046==    by 0x10B35C: main (testcase.c:334)
==1046== 
==1046== 13 bytes in 1 blocks are still reachable in loss record 3 of 5
==1046==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1046==    by 0x109DEA: create_request (server.c:344)
==1046==    by 0x10AAA5: run_test (testcase.c:77)
==1046==    by 0x10AD6D: get5 (testcase.c:148)
==1046==    by 0x10B35C: main (testcase.c:334)
==1046== 
==1046== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==1046==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1046==    by 0x109A95: create_request (server.c:277)
==1046==    by 0x10AAA5: run_test (testcase.c:77)
==1046==    by 0x10AD6D: get5 (testcase.c:148)
==1046==    by 0x10B35C: main (testcase.c:334)
==1046== 
==1046== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==1046==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1046==    by 0x10AA7D: run_test (testcase.c:73)
==1046==    by 0x10AD6D: get5 (testcase.c:148)
==1046==    by 0x10B35C: main (testcase.c:334)
==1046== 
==1046== LEAK SUMMARY:
==1046==    definitely lost: 0 bytes in 0 blocks
==1046==    indirectly lost: 0 bytes in 0 blocks
==1046==      possibly lost: 0 bytes in 0 blocks
==1046==    still reachable: 326 bytes in 5 blocks
==1046==         suppressed: 0 bytes in 0 blocks
==1046== 
==1046== Use --track-origins=yes to see where uninitialised values come from
==1046== For lists of detected and suppressed errors, rerun with: -s
==1046== ERROR SUMMARY: 230 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc6
\n------------------------\n\n\n
==1049== Memcheck, a memory error detector
==1049== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1049== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1049== Command: ./testcase tc6
==1049== 
==1049== Conditional jump or move depends on uninitialised value(s)
==1049==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1049==    by 0x10981B: unallocate_request (server.c:160)
==1049==    by 0x10AB14: run_test (testcase.c:90)
==1049==    by 0x10AE16: method1 (testcase.c:162)
==1049==    by 0x10B35C: main (testcase.c:334)
==1049== 
==1049== Conditional jump or move depends on uninitialised value(s)
==1049==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1049==    by 0x10982E: unallocate_request (server.c:161)
==1049==    by 0x10AB14: run_test (testcase.c:90)
==1049==    by 0x10AE16: method1 (testcase.c:162)
==1049==    by 0x10B35C: main (testcase.c:334)
==1049== 
==1049== Conditional jump or move depends on uninitialised value(s)
==1049==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1049==    by 0x109841: unallocate_request (server.c:162)
==1049==    by 0x10AB14: run_test (testcase.c:90)
==1049==    by 0x10AE16: method1 (testcase.c:162)
==1049==    by 0x10B35C: main (testcase.c:334)
==1049== 
==1049== Conditional jump or move depends on uninitialised value(s)
==1049==    at 0x10989E: unallocate_request (server.c:167)
==1049==    by 0x10AB14: run_test (testcase.c:90)
==1049==    by 0x10AE16: method1 (testcase.c:162)
==1049==    by 0x10B35C: main (testcase.c:334)
==1049== 
==1049== 
==1049== HEAP SUMMARY:
==1049==     in use at exit: 0 bytes in 0 blocks
==1049==   total heap usage: 4 allocs, 4 frees, 1,324 bytes allocated
==1049== 
==1049== All heap blocks were freed -- no leaks are possible
==1049== 
==1049== Use --track-origins=yes to see where uninitialised values come from
==1049== For lists of detected and suppressed errors, rerun with: -s
==1049== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc7
\n------------------------\n\n\n
==1052== Memcheck, a memory error detector
==1052== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1052== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1052== Command: ./testcase tc7
==1052== 
==1052== Conditional jump or move depends on uninitialised value(s)
==1052==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1052==    by 0x10981B: unallocate_request (server.c:160)
==1052==    by 0x10AB14: run_test (testcase.c:90)
==1052==    by 0x10AED3: method2 (testcase.c:172)
==1052==    by 0x10B35C: main (testcase.c:334)
==1052== 
==1052== Conditional jump or move depends on uninitialised value(s)
==1052==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1052==    by 0x10982E: unallocate_request (server.c:161)
==1052==    by 0x10AB14: run_test (testcase.c:90)
==1052==    by 0x10AED3: method2 (testcase.c:172)
==1052==    by 0x10B35C: main (testcase.c:334)
==1052== 
==1052== Conditional jump or move depends on uninitialised value(s)
==1052==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1052==    by 0x109841: unallocate_request (server.c:162)
==1052==    by 0x10AB14: run_test (testcase.c:90)
==1052==    by 0x10AED3: method2 (testcase.c:172)
==1052==    by 0x10B35C: main (testcase.c:334)
==1052== 
==1052== Conditional jump or move depends on uninitialised value(s)
==1052==    at 0x10989E: unallocate_request (server.c:167)
==1052==    by 0x10AB14: run_test (testcase.c:90)
==1052==    by 0x10AED3: method2 (testcase.c:172)
==1052==    by 0x10B35C: main (testcase.c:334)
==1052== 
==1052== 
==1052== HEAP SUMMARY:
==1052==     in use at exit: 0 bytes in 0 blocks
==1052==   total heap usage: 4 allocs, 4 frees, 1,325 bytes allocated
==1052== 
==1052== All heap blocks were freed -- no leaks are possible
==1052== 
==1052== Use --track-origins=yes to see where uninitialised values come from
==1052== For lists of detected and suppressed errors, rerun with: -s
==1052== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc8
\n------------------------\n\n\n
==1055== Memcheck, a memory error detector
==1055== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1055== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1055== Command: ./testcase tc8
==1055== 
==1055== Conditional jump or move depends on uninitialised value(s)
==1055==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1055==    by 0x10981B: unallocate_request (server.c:160)
==1055==    by 0x10AB14: run_test (testcase.c:90)
==1055==    by 0x10AF35: method3 (testcase.c:182)
==1055==    by 0x10B35C: main (testcase.c:334)
==1055== 
==1055== Conditional jump or move depends on uninitialised value(s)
==1055==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1055==    by 0x10982E: unallocate_request (server.c:161)
==1055==    by 0x10AB14: run_test (testcase.c:90)
==1055==    by 0x10AF35: method3 (testcase.c:182)
==1055==    by 0x10B35C: main (testcase.c:334)
==1055== 
==1055== Conditional jump or move depends on uninitialised value(s)
==1055==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1055==    by 0x109841: unallocate_request (server.c:162)
==1055==    by 0x10AB14: run_test (testcase.c:90)
==1055==    by 0x10AF35: method3 (testcase.c:182)
==1055==    by 0x10B35C: main (testcase.c:334)
==1055== 
==1055== Conditional jump or move depends on uninitialised value(s)
==1055==    at 0x10989E: unallocate_request (server.c:167)
==1055==    by 0x10AB14: run_test (testcase.c:90)
==1055==    by 0x10AF35: method3 (testcase.c:182)
==1055==    by 0x10B35C: main (testcase.c:334)
==1055== 
==1055== 
==1055== HEAP SUMMARY:
==1055==     in use at exit: 0 bytes in 0 blocks
==1055==   total heap usage: 3 allocs, 3 frees, 301 bytes allocated
==1055== 
==1055== All heap blocks were freed -- no leaks are possible
==1055== 
==1055== Use --track-origins=yes to see where uninitialised values come from
==1055== For lists of detected and suppressed errors, rerun with: -s
==1055== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc9
\n------------------------\n\n\n
==1058== Memcheck, a memory error detector
==1058== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1058== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1058== Command: ./testcase tc9
==1058== 
==1058== 
==1058== HEAP SUMMARY:
==1058==     in use at exit: 0 bytes in 0 blocks
==1058==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==1058== 
==1058== All heap blocks were freed -- no leaks are possible
==1058== 
==1058== For lists of detected and suppressed errors, rerun with: -s
==1058== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc10
\n------------------------\n\n\n
==1061== Memcheck, a memory error detector
==1061== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1061== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1061== Command: ./testcase tc10
==1061== 
==1061== 
==1061== HEAP SUMMARY:
==1061==     in use at exit: 0 bytes in 0 blocks
==1061==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==1061== 
==1061== All heap blocks were freed -- no leaks are possible
==1061== 
==1061== For lists of detected and suppressed errors, rerun with: -s
==1061== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc11
\n------------------------\n\n\n
==1064== Memcheck, a memory error detector
==1064== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1064== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1064== Command: ./testcase tc11
==1064== 
==1064== 
==1064== HEAP SUMMARY:
==1064==     in use at exit: 0 bytes in 0 blocks
==1064==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==1064== 
==1064== All heap blocks were freed -- no leaks are possible
==1064== 
==1064== For lists of detected and suppressed errors, rerun with: -s
==1064== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc12
\n------------------------\n\n\n
==1067== Memcheck, a memory error detector
==1067== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1067== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1067== Command: ./testcase tc12
==1067== 
==1067== 
==1067== HEAP SUMMARY:
==1067==     in use at exit: 0 bytes in 0 blocks
==1067==   total heap usage: 7 allocs, 7 frees, 1,346 bytes allocated
==1067== 
==1067== All heap blocks were freed -- no leaks are possible
==1067== 
==1067== For lists of detected and suppressed errors, rerun with: -s
==1067== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc13
\n------------------------\n\n\n
==1070== Memcheck, a memory error detector
==1070== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1070== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1070== Command: ./testcase tc13
==1070== 
==1070== 
==1070== HEAP SUMMARY:
==1070==     in use at exit: 0 bytes in 0 blocks
==1070==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==1070== 
==1070== All heap blocks were freed -- no leaks are possible
==1070== 
==1070== For lists of detected and suppressed errors, rerun with: -s
==1070== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc1
\n------------------------\n\n\n
==1075== Memcheck, a memory error detector
==1075== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1075== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1075== Command: ./testcase tc1
==1075== 
==1075== 
==1075== HEAP SUMMARY:
==1075==     in use at exit: 0 bytes in 0 blocks
==1075==   total heap usage: 7 allocs, 7 frees, 864 bytes allocated
==1075== 
==1075== All heap blocks were freed -- no leaks are possible
==1075== 
==1075== For lists of detected and suppressed errors, rerun with: -s
==1075== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc2
\n------------------------\n\n\n
==1078== Memcheck, a memory error detector
==1078== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1078== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1078== Command: ./testcase tc2
==1078== 
==1078== 
==1078== HEAP SUMMARY:
==1078==     in use at exit: 0 bytes in 0 blocks
==1078==   total heap usage: 9 allocs, 9 frees, 1,946 bytes allocated
==1078== 
==1078== All heap blocks were freed -- no leaks are possible
==1078== 
==1078== For lists of detected and suppressed errors, rerun with: -s
==1078== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc3
\n------------------------\n\n\n
==1081== Memcheck, a memory error detector
==1081== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1081== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1081== Command: ./testcase tc3
==1081== 
==1081== Use of uninitialised value of size 8
==1081==    at 0x10A325: create_request (server.c:419)
==1081==    by 0x10AAA5: run_test (testcase.c:77)
==1081==    by 0x10ACD1: get3 (testcase.c:138)
==1081==    by 0x10B35C: main (testcase.c:334)
==1081== 
==1081== Invalid read of size 1
==1081==    at 0x10A325: create_request (server.c:419)
==1081==    by 0x10AAA5: run_test (testcase.c:77)
==1081==    by 0x10ACD1: get3 (testcase.c:138)
==1081==    by 0x10B35C: main (testcase.c:334)
==1081==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==1081== 
==1081== 
==1081== Process terminating with default action of signal 11 (SIGSEGV)
==1081==  Access not within mapped region at address 0x0
==1081==    at 0x10A325: create_request (server.c:419)
==1081==    by 0x10AAA5: run_test (testcase.c:77)
==1081==    by 0x10ACD1: get3 (testcase.c:138)
==1081==    by 0x10B35C: main (testcase.c:334)
==1081==  If you believe this happened as a result of a stack
==1081==  overflow in your program's main thread (unlikely but
==1081==  possible), you can try to increase the size of the
==1081==  main thread stack using the --main-stacksize= flag.
==1081==  The main thread stack size used in this run was 8388608.
==1081== 
==1081== HEAP SUMMARY:
==1081==     in use at exit: 320 bytes in 5 blocks
==1081==   total heap usage: 5 allocs, 0 frees, 320 bytes allocated
==1081== 
==1081== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==1081==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1081==    by 0x109AFB: create_request (server.c:286)
==1081==    by 0x10AAA5: run_test (testcase.c:77)
==1081==    by 0x10ACD1: get3 (testcase.c:138)
==1081==    by 0x10B35C: main (testcase.c:334)
==1081== 
==1081== 10 bytes in 1 blocks are still reachable in loss record 2 of 5
==1081==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1081==    by 0x109DB1: create_request (server.c:342)
==1081==    by 0x10AAA5: run_test (testcase.c:77)
==1081==    by 0x10ACD1: get3 (testcase.c:138)
==1081==    by 0x10B35C: main (testcase.c:334)
==1081== 
==1081== 10 bytes in 1 blocks are still reachable in loss record 3 of 5
==1081==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1081==    by 0x109DEA: create_request (server.c:344)
==1081==    by 0x10AAA5: run_test (testcase.c:77)
==1081==    by 0x10ACD1: get3 (testcase.c:138)
==1081==    by 0x10B35C: main (testcase.c:334)
==1081== 
==1081== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==1081==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1081==    by 0x109A95: create_request (server.c:277)
==1081==    by 0x10AAA5: run_test (testcase.c:77)
==1081==    by 0x10ACD1: get3 (testcase.c:138)
==1081==    by 0x10B35C: main (testcase.c:334)
==1081== 
==1081== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==1081==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1081==    by 0x10AA7D: run_test (testcase.c:73)
==1081==    by 0x10ACD1: get3 (testcase.c:138)
==1081==    by 0x10B35C: main (testcase.c:334)
==1081== 
==1081== LEAK SUMMARY:
==1081==    definitely lost: 0 bytes in 0 blocks
==1081==    indirectly lost: 0 bytes in 0 blocks
==1081==      possibly lost: 0 bytes in 0 blocks
==1081==    still reachable: 320 bytes in 5 blocks
==1081==         suppressed: 0 bytes in 0 blocks
==1081== 
==1081== Use --track-origins=yes to see where uninitialised values come from
==1081== For lists of detected and suppressed errors, rerun with: -s
==1081== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc4
\n------------------------\n\n\n
==1084== Memcheck, a memory error detector
==1084== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1084== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1084== Command: ./testcase tc4
==1084== 
==1084== 
==1084== HEAP SUMMARY:
==1084==     in use at exit: 0 bytes in 0 blocks
==1084==   total heap usage: 7 allocs, 7 frees, 1,348 bytes allocated
==1084== 
==1084== All heap blocks were freed -- no leaks are possible
==1084== 
==1084== For lists of detected and suppressed errors, rerun with: -s
==1084== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc5
\n------------------------\n\n\n
==1087== Memcheck, a memory error detector
==1087== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1087== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1087== Command: ./testcase tc5
==1087== 
==1087== Invalid read of size 1
==1087==    at 0x109E3E: create_request (server.c:352)
==1087==    by 0x10AAA5: run_test (testcase.c:77)
==1087==    by 0x10AD6D: get5 (testcase.c:148)
==1087==    by 0x10B35C: main (testcase.c:334)
==1087==  Address 0x4a78140 is 0 bytes after a block of size 256 alloc'd
==1087==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1087==    by 0x10AA7D: run_test (testcase.c:73)
==1087==    by 0x10AD6D: get5 (testcase.c:148)
==1087==    by 0x10B35C: main (testcase.c:334)
==1087== 
==1087== Conditional jump or move depends on uninitialised value(s)
==1087==    at 0x109E43: create_request (server.c:352)
==1087==    by 0x10AAA5: run_test (testcase.c:77)
==1087==    by 0x10AD6D: get5 (testcase.c:148)
==1087==    by 0x10B35C: main (testcase.c:334)
==1087== 
==1087== Use of uninitialised value of size 8
==1087==    at 0x10A325: create_request (server.c:419)
==1087==    by 0x10AAA5: run_test (testcase.c:77)
==1087==    by 0x10AD6D: get5 (testcase.c:148)
==1087==    by 0x10B35C: main (testcase.c:334)
==1087== 
==1087== Invalid read of size 1
==1087==    at 0x10A325: create_request (server.c:419)
==1087==    by 0x10AAA5: run_test (testcase.c:77)
==1087==    by 0x10AD6D: get5 (testcase.c:148)
==1087==    by 0x10B35C: main (testcase.c:334)
==1087==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==1087== 
==1087== 
==1087== Process terminating with default action of signal 11 (SIGSEGV)
==1087==  Access not within mapped region at address 0x0
==1087==    at 0x10A325: create_request (server.c:419)
==1087==    by 0x10AAA5: run_test (testcase.c:77)
==1087==    by 0x10AD6D: get5 (testcase.c:148)
==1087==    by 0x10B35C: main (testcase.c:334)
==1087==  If you believe this happened as a result of a stack
==1087==  overflow in your program's main thread (unlikely but
==1087==  possible), you can try to increase the size of the
==1087==  main thread stack using the --main-stacksize= flag.
==1087==  The main thread stack size used in this run was 8388608.
==1087== 
==1087== HEAP SUMMARY:
==1087==     in use at exit: 326 bytes in 5 blocks
==1087==   total heap usage: 5 allocs, 0 frees, 326 bytes allocated
==1087== 
==1087== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==1087==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1087==    by 0x109AFB: create_request (server.c:286)
==1087==    by 0x10AAA5: run_test (testcase.c:77)
==1087==    by 0x10AD6D: get5 (testcase.c:148)
==1087==    by 0x10B35C: main (testcase.c:334)
==1087== 
==1087== 13 bytes in 1 blocks are still reachable in loss record 2 of 5
==1087==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1087==    by 0x109DB1: create_request (server.c:342)
==1087==    by 0x10AAA5: run_test (testcase.c:77)
==1087==    by 0x10AD6D: get5 (testcase.c:148)
==1087==    by 0x10B35C: main (testcase.c:334)
==1087== 
==1087== 13 bytes in 1 blocks are still reachable in loss record 3 of 5
==1087==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1087==    by 0x109DEA: create_request (server.c:344)
==1087==    by 0x10AAA5: run_test (testcase.c:77)
==1087==    by 0x10AD6D: get5 (testcase.c:148)
==1087==    by 0x10B35C: main (testcase.c:334)
==1087== 
==1087== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==1087==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1087==    by 0x109A95: create_request (server.c:277)
==1087==    by 0x10AAA5: run_test (testcase.c:77)
==1087==    by 0x10AD6D: get5 (testcase.c:148)
==1087==    by 0x10B35C: main (testcase.c:334)
==1087== 
==1087== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==1087==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1087==    by 0x10AA7D: run_test (testcase.c:73)
==1087==    by 0x10AD6D: get5 (testcase.c:148)
==1087==    by 0x10B35C: main (testcase.c:334)
==1087== 
==1087== LEAK SUMMARY:
==1087==    definitely lost: 0 bytes in 0 blocks
==1087==    indirectly lost: 0 bytes in 0 blocks
==1087==      possibly lost: 0 bytes in 0 blocks
==1087==    still reachable: 326 bytes in 5 blocks
==1087==         suppressed: 0 bytes in 0 blocks
==1087== 
==1087== Use --track-origins=yes to see where uninitialised values come from
==1087== For lists of detected and suppressed errors, rerun with: -s
==1087== ERROR SUMMARY: 230 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc6
\n------------------------\n\n\n
==1090== Memcheck, a memory error detector
==1090== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1090== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1090== Command: ./testcase tc6
==1090== 
==1090== Conditional jump or move depends on uninitialised value(s)
==1090==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1090==    by 0x10981B: unallocate_request (server.c:160)
==1090==    by 0x10AB14: run_test (testcase.c:90)
==1090==    by 0x10AE16: method1 (testcase.c:162)
==1090==    by 0x10B35C: main (testcase.c:334)
==1090== 
==1090== Conditional jump or move depends on uninitialised value(s)
==1090==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1090==    by 0x10982E: unallocate_request (server.c:161)
==1090==    by 0x10AB14: run_test (testcase.c:90)
==1090==    by 0x10AE16: method1 (testcase.c:162)
==1090==    by 0x10B35C: main (testcase.c:334)
==1090== 
==1090== Conditional jump or move depends on uninitialised value(s)
==1090==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1090==    by 0x109841: unallocate_request (server.c:162)
==1090==    by 0x10AB14: run_test (testcase.c:90)
==1090==    by 0x10AE16: method1 (testcase.c:162)
==1090==    by 0x10B35C: main (testcase.c:334)
==1090== 
==1090== Conditional jump or move depends on uninitialised value(s)
==1090==    at 0x10989E: unallocate_request (server.c:167)
==1090==    by 0x10AB14: run_test (testcase.c:90)
==1090==    by 0x10AE16: method1 (testcase.c:162)
==1090==    by 0x10B35C: main (testcase.c:334)
==1090== 
==1090== 
==1090== HEAP SUMMARY:
==1090==     in use at exit: 0 bytes in 0 blocks
==1090==   total heap usage: 4 allocs, 4 frees, 1,324 bytes allocated
==1090== 
==1090== All heap blocks were freed -- no leaks are possible
==1090== 
==1090== Use --track-origins=yes to see where uninitialised values come from
==1090== For lists of detected and suppressed errors, rerun with: -s
==1090== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc7
\n------------------------\n\n\n
==1093== Memcheck, a memory error detector
==1093== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1093== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1093== Command: ./testcase tc7
==1093== 
==1093== Conditional jump or move depends on uninitialised value(s)
==1093==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1093==    by 0x10981B: unallocate_request (server.c:160)
==1093==    by 0x10AB14: run_test (testcase.c:90)
==1093==    by 0x10AED3: method2 (testcase.c:172)
==1093==    by 0x10B35C: main (testcase.c:334)
==1093== 
==1093== Conditional jump or move depends on uninitialised value(s)
==1093==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1093==    by 0x10982E: unallocate_request (server.c:161)
==1093==    by 0x10AB14: run_test (testcase.c:90)
==1093==    by 0x10AED3: method2 (testcase.c:172)
==1093==    by 0x10B35C: main (testcase.c:334)
==1093== 
==1093== Conditional jump or move depends on uninitialised value(s)
==1093==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1093==    by 0x109841: unallocate_request (server.c:162)
==1093==    by 0x10AB14: run_test (testcase.c:90)
==1093==    by 0x10AED3: method2 (testcase.c:172)
==1093==    by 0x10B35C: main (testcase.c:334)
==1093== 
==1093== Conditional jump or move depends on uninitialised value(s)
==1093==    at 0x10989E: unallocate_request (server.c:167)
==1093==    by 0x10AB14: run_test (testcase.c:90)
==1093==    by 0x10AED3: method2 (testcase.c:172)
==1093==    by 0x10B35C: main (testcase.c:334)
==1093== 
==1093== 
==1093== HEAP SUMMARY:
==1093==     in use at exit: 0 bytes in 0 blocks
==1093==   total heap usage: 4 allocs, 4 frees, 1,325 bytes allocated
==1093== 
==1093== All heap blocks were freed -- no leaks are possible
==1093== 
==1093== Use --track-origins=yes to see where uninitialised values come from
==1093== For lists of detected and suppressed errors, rerun with: -s
==1093== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc8
\n------------------------\n\n\n
==1096== Memcheck, a memory error detector
==1096== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1096== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1096== Command: ./testcase tc8
==1096== 
==1096== Conditional jump or move depends on uninitialised value(s)
==1096==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1096==    by 0x10981B: unallocate_request (server.c:160)
==1096==    by 0x10AB14: run_test (testcase.c:90)
==1096==    by 0x10AF35: method3 (testcase.c:182)
==1096==    by 0x10B35C: main (testcase.c:334)
==1096== 
==1096== Conditional jump or move depends on uninitialised value(s)
==1096==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1096==    by 0x10982E: unallocate_request (server.c:161)
==1096==    by 0x10AB14: run_test (testcase.c:90)
==1096==    by 0x10AF35: method3 (testcase.c:182)
==1096==    by 0x10B35C: main (testcase.c:334)
==1096== 
==1096== Conditional jump or move depends on uninitialised value(s)
==1096==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1096==    by 0x109841: unallocate_request (server.c:162)
==1096==    by 0x10AB14: run_test (testcase.c:90)
==1096==    by 0x10AF35: method3 (testcase.c:182)
==1096==    by 0x10B35C: main (testcase.c:334)
==1096== 
==1096== Conditional jump or move depends on uninitialised value(s)
==1096==    at 0x10989E: unallocate_request (server.c:167)
==1096==    by 0x10AB14: run_test (testcase.c:90)
==1096==    by 0x10AF35: method3 (testcase.c:182)
==1096==    by 0x10B35C: main (testcase.c:334)
==1096== 
==1096== 
==1096== HEAP SUMMARY:
==1096==     in use at exit: 0 bytes in 0 blocks
==1096==   total heap usage: 3 allocs, 3 frees, 301 bytes allocated
==1096== 
==1096== All heap blocks were freed -- no leaks are possible
==1096== 
==1096== Use --track-origins=yes to see where uninitialised values come from
==1096== For lists of detected and suppressed errors, rerun with: -s
==1096== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc9
\n------------------------\n\n\n
==1099== Memcheck, a memory error detector
==1099== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1099== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1099== Command: ./testcase tc9
==1099== 
==1099== 
==1099== HEAP SUMMARY:
==1099==     in use at exit: 0 bytes in 0 blocks
==1099==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==1099== 
==1099== All heap blocks were freed -- no leaks are possible
==1099== 
==1099== For lists of detected and suppressed errors, rerun with: -s
==1099== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc10
\n------------------------\n\n\n
==1102== Memcheck, a memory error detector
==1102== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1102== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1102== Command: ./testcase tc10
==1102== 
==1102== 
==1102== HEAP SUMMARY:
==1102==     in use at exit: 0 bytes in 0 blocks
==1102==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==1102== 
==1102== All heap blocks were freed -- no leaks are possible
==1102== 
==1102== For lists of detected and suppressed errors, rerun with: -s
==1102== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc11
\n------------------------\n\n\n
==1105== Memcheck, a memory error detector
==1105== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1105== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1105== Command: ./testcase tc11
==1105== 
==1105== 
==1105== HEAP SUMMARY:
==1105==     in use at exit: 0 bytes in 0 blocks
==1105==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==1105== 
==1105== All heap blocks were freed -- no leaks are possible
==1105== 
==1105== For lists of detected and suppressed errors, rerun with: -s
==1105== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc12
\n------------------------\n\n\n
==1108== Memcheck, a memory error detector
==1108== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1108== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1108== Command: ./testcase tc12
==1108== 
==1108== 
==1108== HEAP SUMMARY:
==1108==     in use at exit: 0 bytes in 0 blocks
==1108==   total heap usage: 7 allocs, 7 frees, 1,346 bytes allocated
==1108== 
==1108== All heap blocks were freed -- no leaks are possible
==1108== 
==1108== For lists of detected and suppressed errors, rerun with: -s
==1108== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc13
\n------------------------\n\n\n
==1111== Memcheck, a memory error detector
==1111== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1111== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1111== Command: ./testcase tc13
==1111== 
==1111== 
==1111== HEAP SUMMARY:
==1111==     in use at exit: 0 bytes in 0 blocks
==1111==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==1111== 
==1111== All heap blocks were freed -- no leaks are possible
==1111== 
==1111== For lists of detected and suppressed errors, rerun with: -s
==1111== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc1
\n------------------------\n\n\n
==1136== Memcheck, a memory error detector
==1136== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1136== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1136== Command: ./testcase tc1
==1136== 
==1136== 
==1136== HEAP SUMMARY:
==1136==     in use at exit: 0 bytes in 0 blocks
==1136==   total heap usage: 7 allocs, 7 frees, 864 bytes allocated
==1136== 
==1136== All heap blocks were freed -- no leaks are possible
==1136== 
==1136== For lists of detected and suppressed errors, rerun with: -s
==1136== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc2
\n------------------------\n\n\n
==1139== Memcheck, a memory error detector
==1139== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1139== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1139== Command: ./testcase tc2
==1139== 
==1139== 
==1139== HEAP SUMMARY:
==1139==     in use at exit: 0 bytes in 0 blocks
==1139==   total heap usage: 9 allocs, 9 frees, 1,946 bytes allocated
==1139== 
==1139== All heap blocks were freed -- no leaks are possible
==1139== 
==1139== For lists of detected and suppressed errors, rerun with: -s
==1139== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc3
\n------------------------\n\n\n
==1142== Memcheck, a memory error detector
==1142== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1142== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1142== Command: ./testcase tc3
==1142== 
==1142== Use of uninitialised value of size 8
==1142==    at 0x10B325: create_request (server.c:419)
==1142==    by 0x10BAA5: run_test (testcase.c:73)
==1142==    by 0x10BCD1: get3 (testcase.c:134)
==1142==    by 0x10C9FA: main (testcase.c:429)
==1142== 
==1142== Invalid read of size 1
==1142==    at 0x10B325: create_request (server.c:419)
==1142==    by 0x10BAA5: run_test (testcase.c:73)
==1142==    by 0x10BCD1: get3 (testcase.c:134)
==1142==    by 0x10C9FA: main (testcase.c:429)
==1142==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==1142== 
==1142== 
==1142== Process terminating with default action of signal 11 (SIGSEGV)
==1142==  Access not within mapped region at address 0x0
==1142==    at 0x10B325: create_request (server.c:419)
==1142==    by 0x10BAA5: run_test (testcase.c:73)
==1142==    by 0x10BCD1: get3 (testcase.c:134)
==1142==    by 0x10C9FA: main (testcase.c:429)
==1142==  If you believe this happened as a result of a stack
==1142==  overflow in your program's main thread (unlikely but
==1142==  possible), you can try to increase the size of the
==1142==  main thread stack using the --main-stacksize= flag.
==1142==  The main thread stack size used in this run was 8388608.
==1142== 
==1142== HEAP SUMMARY:
==1142==     in use at exit: 320 bytes in 5 blocks
==1142==   total heap usage: 5 allocs, 0 frees, 320 bytes allocated
==1142== 
==1142== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==1142==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1142==    by 0x10AAFB: create_request (server.c:286)
==1142==    by 0x10BAA5: run_test (testcase.c:73)
==1142==    by 0x10BCD1: get3 (testcase.c:134)
==1142==    by 0x10C9FA: main (testcase.c:429)
==1142== 
==1142== 10 bytes in 1 blocks are still reachable in loss record 2 of 5
==1142==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1142==    by 0x10ADB1: create_request (server.c:342)
==1142==    by 0x10BAA5: run_test (testcase.c:73)
==1142==    by 0x10BCD1: get3 (testcase.c:134)
==1142==    by 0x10C9FA: main (testcase.c:429)
==1142== 
==1142== 10 bytes in 1 blocks are still reachable in loss record 3 of 5
==1142==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1142==    by 0x10ADEA: create_request (server.c:344)
==1142==    by 0x10BAA5: run_test (testcase.c:73)
==1142==    by 0x10BCD1: get3 (testcase.c:134)
==1142==    by 0x10C9FA: main (testcase.c:429)
==1142== 
==1142== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==1142==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1142==    by 0x10AA95: create_request (server.c:277)
==1142==    by 0x10BAA5: run_test (testcase.c:73)
==1142==    by 0x10BCD1: get3 (testcase.c:134)
==1142==    by 0x10C9FA: main (testcase.c:429)
==1142== 
==1142== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==1142==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1142==    by 0x10BA7D: run_test (testcase.c:69)
==1142==    by 0x10BCD1: get3 (testcase.c:134)
==1142==    by 0x10C9FA: main (testcase.c:429)
==1142== 
==1142== LEAK SUMMARY:
==1142==    definitely lost: 0 bytes in 0 blocks
==1142==    indirectly lost: 0 bytes in 0 blocks
==1142==      possibly lost: 0 bytes in 0 blocks
==1142==    still reachable: 320 bytes in 5 blocks
==1142==         suppressed: 0 bytes in 0 blocks
==1142== 
==1142== Use --track-origins=yes to see where uninitialised values come from
==1142== For lists of detected and suppressed errors, rerun with: -s
==1142== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc4
\n------------------------\n\n\n
==1145== Memcheck, a memory error detector
==1145== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1145== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1145== Command: ./testcase tc4
==1145== 
==1145== 
==1145== HEAP SUMMARY:
==1145==     in use at exit: 0 bytes in 0 blocks
==1145==   total heap usage: 7 allocs, 7 frees, 1,348 bytes allocated
==1145== 
==1145== All heap blocks were freed -- no leaks are possible
==1145== 
==1145== For lists of detected and suppressed errors, rerun with: -s
==1145== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc5
\n------------------------\n\n\n
==1148== Memcheck, a memory error detector
==1148== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1148== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1148== Command: ./testcase tc5
==1148== 
==1148== Invalid read of size 1
==1148==    at 0x10AE3E: create_request (server.c:352)
==1148==    by 0x10BAA5: run_test (testcase.c:73)
==1148==    by 0x10BD6D: get5 (testcase.c:144)
==1148==    by 0x10C9FA: main (testcase.c:429)
==1148==  Address 0x4a78140 is 0 bytes after a block of size 256 alloc'd
==1148==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1148==    by 0x10BA7D: run_test (testcase.c:69)
==1148==    by 0x10BD6D: get5 (testcase.c:144)
==1148==    by 0x10C9FA: main (testcase.c:429)
==1148== 
==1148== Conditional jump or move depends on uninitialised value(s)
==1148==    at 0x10AE43: create_request (server.c:352)
==1148==    by 0x10BAA5: run_test (testcase.c:73)
==1148==    by 0x10BD6D: get5 (testcase.c:144)
==1148==    by 0x10C9FA: main (testcase.c:429)
==1148== 
==1148== Use of uninitialised value of size 8
==1148==    at 0x10B325: create_request (server.c:419)
==1148==    by 0x10BAA5: run_test (testcase.c:73)
==1148==    by 0x10BD6D: get5 (testcase.c:144)
==1148==    by 0x10C9FA: main (testcase.c:429)
==1148== 
==1148== Invalid read of size 1
==1148==    at 0x10B325: create_request (server.c:419)
==1148==    by 0x10BAA5: run_test (testcase.c:73)
==1148==    by 0x10BD6D: get5 (testcase.c:144)
==1148==    by 0x10C9FA: main (testcase.c:429)
==1148==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==1148== 
==1148== 
==1148== Process terminating with default action of signal 11 (SIGSEGV)
==1148==  Access not within mapped region at address 0x0
==1148==    at 0x10B325: create_request (server.c:419)
==1148==    by 0x10BAA5: run_test (testcase.c:73)
==1148==    by 0x10BD6D: get5 (testcase.c:144)
==1148==    by 0x10C9FA: main (testcase.c:429)
==1148==  If you believe this happened as a result of a stack
==1148==  overflow in your program's main thread (unlikely but
==1148==  possible), you can try to increase the size of the
==1148==  main thread stack using the --main-stacksize= flag.
==1148==  The main thread stack size used in this run was 8388608.
==1148== 
==1148== HEAP SUMMARY:
==1148==     in use at exit: 326 bytes in 5 blocks
==1148==   total heap usage: 5 allocs, 0 frees, 326 bytes allocated
==1148== 
==1148== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==1148==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1148==    by 0x10AAFB: create_request (server.c:286)
==1148==    by 0x10BAA5: run_test (testcase.c:73)
==1148==    by 0x10BD6D: get5 (testcase.c:144)
==1148==    by 0x10C9FA: main (testcase.c:429)
==1148== 
==1148== 13 bytes in 1 blocks are still reachable in loss record 2 of 5
==1148==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1148==    by 0x10ADB1: create_request (server.c:342)
==1148==    by 0x10BAA5: run_test (testcase.c:73)
==1148==    by 0x10BD6D: get5 (testcase.c:144)
==1148==    by 0x10C9FA: main (testcase.c:429)
==1148== 
==1148== 13 bytes in 1 blocks are still reachable in loss record 3 of 5
==1148==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1148==    by 0x10ADEA: create_request (server.c:344)
==1148==    by 0x10BAA5: run_test (testcase.c:73)
==1148==    by 0x10BD6D: get5 (testcase.c:144)
==1148==    by 0x10C9FA: main (testcase.c:429)
==1148== 
==1148== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==1148==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1148==    by 0x10AA95: create_request (server.c:277)
==1148==    by 0x10BAA5: run_test (testcase.c:73)
==1148==    by 0x10BD6D: get5 (testcase.c:144)
==1148==    by 0x10C9FA: main (testcase.c:429)
==1148== 
==1148== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==1148==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1148==    by 0x10BA7D: run_test (testcase.c:69)
==1148==    by 0x10BD6D: get5 (testcase.c:144)
==1148==    by 0x10C9FA: main (testcase.c:429)
==1148== 
==1148== LEAK SUMMARY:
==1148==    definitely lost: 0 bytes in 0 blocks
==1148==    indirectly lost: 0 bytes in 0 blocks
==1148==      possibly lost: 0 bytes in 0 blocks
==1148==    still reachable: 326 bytes in 5 blocks
==1148==         suppressed: 0 bytes in 0 blocks
==1148== 
==1148== Use --track-origins=yes to see where uninitialised values come from
==1148== For lists of detected and suppressed errors, rerun with: -s
==1148== ERROR SUMMARY: 230 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc6
\n------------------------\n\n\n
==1151== Memcheck, a memory error detector
==1151== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1151== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1151== Command: ./testcase tc6
==1151== 
==1151== Conditional jump or move depends on uninitialised value(s)
==1151==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1151==    by 0x10A81B: unallocate_request (server.c:160)
==1151==    by 0x10BB14: run_test (testcase.c:86)
==1151==    by 0x10BE16: method1 (testcase.c:158)
==1151==    by 0x10C9FA: main (testcase.c:429)
==1151== 
==1151== Conditional jump or move depends on uninitialised value(s)
==1151==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1151==    by 0x10A82E: unallocate_request (server.c:161)
==1151==    by 0x10BB14: run_test (testcase.c:86)
==1151==    by 0x10BE16: method1 (testcase.c:158)
==1151==    by 0x10C9FA: main (testcase.c:429)
==1151== 
==1151== Conditional jump or move depends on uninitialised value(s)
==1151==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1151==    by 0x10A841: unallocate_request (server.c:162)
==1151==    by 0x10BB14: run_test (testcase.c:86)
==1151==    by 0x10BE16: method1 (testcase.c:158)
==1151==    by 0x10C9FA: main (testcase.c:429)
==1151== 
==1151== Conditional jump or move depends on uninitialised value(s)
==1151==    at 0x10A89E: unallocate_request (server.c:167)
==1151==    by 0x10BB14: run_test (testcase.c:86)
==1151==    by 0x10BE16: method1 (testcase.c:158)
==1151==    by 0x10C9FA: main (testcase.c:429)
==1151== 
==1151== 
==1151== HEAP SUMMARY:
==1151==     in use at exit: 0 bytes in 0 blocks
==1151==   total heap usage: 4 allocs, 4 frees, 1,324 bytes allocated
==1151== 
==1151== All heap blocks were freed -- no leaks are possible
==1151== 
==1151== Use --track-origins=yes to see where uninitialised values come from
==1151== For lists of detected and suppressed errors, rerun with: -s
==1151== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc7
\n------------------------\n\n\n
==1154== Memcheck, a memory error detector
==1154== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1154== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1154== Command: ./testcase tc7
==1154== 
==1154== Conditional jump or move depends on uninitialised value(s)
==1154==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1154==    by 0x10A81B: unallocate_request (server.c:160)
==1154==    by 0x10BB14: run_test (testcase.c:86)
==1154==    by 0x10BED3: method2 (testcase.c:168)
==1154==    by 0x10C9FA: main (testcase.c:429)
==1154== 
==1154== Conditional jump or move depends on uninitialised value(s)
==1154==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1154==    by 0x10A82E: unallocate_request (server.c:161)
==1154==    by 0x10BB14: run_test (testcase.c:86)
==1154==    by 0x10BED3: method2 (testcase.c:168)
==1154==    by 0x10C9FA: main (testcase.c:429)
==1154== 
==1154== Conditional jump or move depends on uninitialised value(s)
==1154==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1154==    by 0x10A841: unallocate_request (server.c:162)
==1154==    by 0x10BB14: run_test (testcase.c:86)
==1154==    by 0x10BED3: method2 (testcase.c:168)
==1154==    by 0x10C9FA: main (testcase.c:429)
==1154== 
==1154== Conditional jump or move depends on uninitialised value(s)
==1154==    at 0x10A89E: unallocate_request (server.c:167)
==1154==    by 0x10BB14: run_test (testcase.c:86)
==1154==    by 0x10BED3: method2 (testcase.c:168)
==1154==    by 0x10C9FA: main (testcase.c:429)
==1154== 
==1154== 
==1154== HEAP SUMMARY:
==1154==     in use at exit: 0 bytes in 0 blocks
==1154==   total heap usage: 4 allocs, 4 frees, 1,325 bytes allocated
==1154== 
==1154== All heap blocks were freed -- no leaks are possible
==1154== 
==1154== Use --track-origins=yes to see where uninitialised values come from
==1154== For lists of detected and suppressed errors, rerun with: -s
==1154== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc8
\n------------------------\n\n\n
==1157== Memcheck, a memory error detector
==1157== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1157== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1157== Command: ./testcase tc8
==1157== 
==1157== Conditional jump or move depends on uninitialised value(s)
==1157==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1157==    by 0x10A81B: unallocate_request (server.c:160)
==1157==    by 0x10BB14: run_test (testcase.c:86)
==1157==    by 0x10BF35: method3 (testcase.c:178)
==1157==    by 0x10C9FA: main (testcase.c:429)
==1157== 
==1157== Conditional jump or move depends on uninitialised value(s)
==1157==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1157==    by 0x10A82E: unallocate_request (server.c:161)
==1157==    by 0x10BB14: run_test (testcase.c:86)
==1157==    by 0x10BF35: method3 (testcase.c:178)
==1157==    by 0x10C9FA: main (testcase.c:429)
==1157== 
==1157== Conditional jump or move depends on uninitialised value(s)
==1157==    at 0x4849845: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1157==    by 0x10A841: unallocate_request (server.c:162)
==1157==    by 0x10BB14: run_test (testcase.c:86)
==1157==    by 0x10BF35: method3 (testcase.c:178)
==1157==    by 0x10C9FA: main (testcase.c:429)
==1157== 
==1157== Conditional jump or move depends on uninitialised value(s)
==1157==    at 0x10A89E: unallocate_request (server.c:167)
==1157==    by 0x10BB14: run_test (testcase.c:86)
==1157==    by 0x10BF35: method3 (testcase.c:178)
==1157==    by 0x10C9FA: main (testcase.c:429)
==1157== 
==1157== 
==1157== HEAP SUMMARY:
==1157==     in use at exit: 0 bytes in 0 blocks
==1157==   total heap usage: 3 allocs, 3 frees, 301 bytes allocated
==1157== 
==1157== All heap blocks were freed -- no leaks are possible
==1157== 
==1157== Use --track-origins=yes to see where uninitialised values come from
==1157== For lists of detected and suppressed errors, rerun with: -s
==1157== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc9
\n------------------------\n\n\n
==1160== Memcheck, a memory error detector
==1160== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1160== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1160== Command: ./testcase tc9
==1160== 
==1160== 
==1160== HEAP SUMMARY:
==1160==     in use at exit: 0 bytes in 0 blocks
==1160==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==1160== 
==1160== All heap blocks were freed -- no leaks are possible
==1160== 
==1160== For lists of detected and suppressed errors, rerun with: -s
==1160== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc10
\n------------------------\n\n\n
==1163== Memcheck, a memory error detector
==1163== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1163== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1163== Command: ./testcase tc10
==1163== 
==1163== 
==1163== HEAP SUMMARY:
==1163==     in use at exit: 0 bytes in 0 blocks
==1163==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==1163== 
==1163== All heap blocks were freed -- no leaks are possible
==1163== 
==1163== For lists of detected and suppressed errors, rerun with: -s
==1163== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc11
\n------------------------\n\n\n
==1166== Memcheck, a memory error detector
==1166== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1166== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1166== Command: ./testcase tc11
==1166== 
==1166== 
==1166== HEAP SUMMARY:
==1166==     in use at exit: 0 bytes in 0 blocks
==1166==   total heap usage: 10 allocs, 10 frees, 2,946 bytes allocated
==1166== 
==1166== All heap blocks were freed -- no leaks are possible
==1166== 
==1166== For lists of detected and suppressed errors, rerun with: -s
==1166== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc12
\n------------------------\n\n\n
==1169== Memcheck, a memory error detector
==1169== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1169== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1169== Command: ./testcase tc12
==1169== 
==1169== 
==1169== HEAP SUMMARY:
==1169==     in use at exit: 0 bytes in 0 blocks
==1169==   total heap usage: 7 allocs, 7 frees, 1,346 bytes allocated
==1169== 
==1169== All heap blocks were freed -- no leaks are possible
==1169== 
==1169== For lists of detected and suppressed errors, rerun with: -s
==1169== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc13
\n------------------------\n\n\n
==1172== Memcheck, a memory error detector
==1172== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1172== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1172== Command: ./testcase tc13
==1172== 
==1172== 
==1172== HEAP SUMMARY:
==1172==     in use at exit: 0 bytes in 0 blocks
==1172==   total heap usage: 8 allocs, 8 frees, 1,877 bytes allocated
==1172== 
==1172== All heap blocks were freed -- no leaks are possible
==1172== 
==1172== For lists of detected and suppressed errors, rerun with: -s
==1172== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc14
\n------------------------\n\n\n
==1175== Memcheck, a memory error detector
==1175== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1175== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1175== Command: ./testcase tc14
==1175== 
==1175== Invalid read of size 1
==1175==    at 0x10AE3E: create_request (server.c:352)
==1175==    by 0x10BAA5: run_test (testcase.c:73)
==1175==    by 0x10C278: url1 (testcase.c:243)
==1175==    by 0x10C9FA: main (testcase.c:429)
==1175==  Address 0x4a78140 is 0 bytes after a block of size 256 alloc'd
==1175==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1175==    by 0x10BA7D: run_test (testcase.c:69)
==1175==    by 0x10C278: url1 (testcase.c:243)
==1175==    by 0x10C9FA: main (testcase.c:429)
==1175== 
==1175== Conditional jump or move depends on uninitialised value(s)
==1175==    at 0x10AE43: create_request (server.c:352)
==1175==    by 0x10BAA5: run_test (testcase.c:73)
==1175==    by 0x10C278: url1 (testcase.c:243)
==1175==    by 0x10C9FA: main (testcase.c:429)
==1175== 
==1175== Use of uninitialised value of size 8
==1175==    at 0x10B325: create_request (server.c:419)
==1175==    by 0x10BAA5: run_test (testcase.c:73)
==1175==    by 0x10C278: url1 (testcase.c:243)
==1175==    by 0x10C9FA: main (testcase.c:429)
==1175== 
==1175== Invalid read of size 1
==1175==    at 0x10B325: create_request (server.c:419)
==1175==    by 0x10BAA5: run_test (testcase.c:73)
==1175==    by 0x10C278: url1 (testcase.c:243)
==1175==    by 0x10C9FA: main (testcase.c:429)
==1175==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==1175== 
==1175== 
==1175== Process terminating with default action of signal 11 (SIGSEGV)
==1175==  Access not within mapped region at address 0x0
==1175==    at 0x10B325: create_request (server.c:419)
==1175==    by 0x10BAA5: run_test (testcase.c:73)
==1175==    by 0x10C278: url1 (testcase.c:243)
==1175==    by 0x10C9FA: main (testcase.c:429)
==1175==  If you believe this happened as a result of a stack
==1175==  overflow in your program's main thread (unlikely but
==1175==  possible), you can try to increase the size of the
==1175==  main thread stack using the --main-stacksize= flag.
==1175==  The main thread stack size used in this run was 8388608.
==1175== 
==1175== HEAP SUMMARY:
==1175==     in use at exit: 326 bytes in 5 blocks
==1175==   total heap usage: 5 allocs, 0 frees, 326 bytes allocated
==1175== 
==1175== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==1175==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1175==    by 0x10AAFB: create_request (server.c:286)
==1175==    by 0x10BAA5: run_test (testcase.c:73)
==1175==    by 0x10C278: url1 (testcase.c:243)
==1175==    by 0x10C9FA: main (testcase.c:429)
==1175== 
==1175== 13 bytes in 1 blocks are still reachable in loss record 2 of 5
==1175==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1175==    by 0x10ADB1: create_request (server.c:342)
==1175==    by 0x10BAA5: run_test (testcase.c:73)
==1175==    by 0x10C278: url1 (testcase.c:243)
==1175==    by 0x10C9FA: main (testcase.c:429)
==1175== 
==1175== 13 bytes in 1 blocks are still reachable in loss record 3 of 5
==1175==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1175==    by 0x10ADEA: create_request (server.c:344)
==1175==    by 0x10BAA5: run_test (testcase.c:73)
==1175==    by 0x10C278: url1 (testcase.c:243)
==1175==    by 0x10C9FA: main (testcase.c:429)
==1175== 
==1175== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==1175==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1175==    by 0x10AA95: create_request (server.c:277)
==1175==    by 0x10BAA5: run_test (testcase.c:73)
==1175==    by 0x10C278: url1 (testcase.c:243)
==1175==    by 0x10C9FA: main (testcase.c:429)
==1175== 
==1175== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==1175==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1175==    by 0x10BA7D: run_test (testcase.c:69)
==1175==    by 0x10C278: url1 (testcase.c:243)
==1175==    by 0x10C9FA: main (testcase.c:429)
==1175== 
==1175== LEAK SUMMARY:
==1175==    definitely lost: 0 bytes in 0 blocks
==1175==    indirectly lost: 0 bytes in 0 blocks
==1175==      possibly lost: 0 bytes in 0 blocks
==1175==    still reachable: 326 bytes in 5 blocks
==1175==         suppressed: 0 bytes in 0 blocks
==1175== 
==1175== Use --track-origins=yes to see where uninitialised values come from
==1175== For lists of detected and suppressed errors, rerun with: -s
==1175== ERROR SUMMARY: 230 errors from 4 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc15
\n------------------------\n\n\n
==1178== Memcheck, a memory error detector
==1178== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1178== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1178== Command: ./testcase tc15
==1178== 
==1178== Use of uninitialised value of size 8
==1178==    at 0x10B325: create_request (server.c:419)
==1178==    by 0x10BAA5: run_test (testcase.c:73)
==1178==    by 0x10C2C6: url2 (testcase.c:248)
==1178==    by 0x10C9FA: main (testcase.c:429)
==1178== 
==1178== Invalid read of size 1
==1178==    at 0x10B325: create_request (server.c:419)
==1178==    by 0x10BAA5: run_test (testcase.c:73)
==1178==    by 0x10C2C6: url2 (testcase.c:248)
==1178==    by 0x10C9FA: main (testcase.c:429)
==1178==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==1178== 
==1178== 
==1178== Process terminating with default action of signal 11 (SIGSEGV)
==1178==  Access not within mapped region at address 0x0
==1178==    at 0x10B325: create_request (server.c:419)
==1178==    by 0x10BAA5: run_test (testcase.c:73)
==1178==    by 0x10C2C6: url2 (testcase.c:248)
==1178==    by 0x10C9FA: main (testcase.c:429)
==1178==  If you believe this happened as a result of a stack
==1178==  overflow in your program's main thread (unlikely but
==1178==  possible), you can try to increase the size of the
==1178==  main thread stack using the --main-stacksize= flag.
==1178==  The main thread stack size used in this run was 8388608.
==1178== 
==1178== HEAP SUMMARY:
==1178==     in use at exit: 322 bytes in 5 blocks
==1178==   total heap usage: 5 allocs, 0 frees, 322 bytes allocated
==1178== 
==1178== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==1178==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1178==    by 0x10AAFB: create_request (server.c:286)
==1178==    by 0x10BAA5: run_test (testcase.c:73)
==1178==    by 0x10C2C6: url2 (testcase.c:248)
==1178==    by 0x10C9FA: main (testcase.c:429)
==1178== 
==1178== 11 bytes in 1 blocks are still reachable in loss record 2 of 5
==1178==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1178==    by 0x10ADB1: create_request (server.c:342)
==1178==    by 0x10BAA5: run_test (testcase.c:73)
==1178==    by 0x10C2C6: url2 (testcase.c:248)
==1178==    by 0x10C9FA: main (testcase.c:429)
==1178== 
==1178== 11 bytes in 1 blocks are still reachable in loss record 3 of 5
==1178==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1178==    by 0x10ADEA: create_request (server.c:344)
==1178==    by 0x10BAA5: run_test (testcase.c:73)
==1178==    by 0x10C2C6: url2 (testcase.c:248)
==1178==    by 0x10C9FA: main (testcase.c:429)
==1178== 
==1178== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==1178==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1178==    by 0x10AA95: create_request (server.c:277)
==1178==    by 0x10BAA5: run_test (testcase.c:73)
==1178==    by 0x10C2C6: url2 (testcase.c:248)
==1178==    by 0x10C9FA: main (testcase.c:429)
==1178== 
==1178== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==1178==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1178==    by 0x10BA7D: run_test (testcase.c:69)
==1178==    by 0x10C2C6: url2 (testcase.c:248)
==1178==    by 0x10C9FA: main (testcase.c:429)
==1178== 
==1178== LEAK SUMMARY:
==1178==    definitely lost: 0 bytes in 0 blocks
==1178==    indirectly lost: 0 bytes in 0 blocks
==1178==      possibly lost: 0 bytes in 0 blocks
==1178==    still reachable: 322 bytes in 5 blocks
==1178==         suppressed: 0 bytes in 0 blocks
==1178== 
==1178== Use --track-origins=yes to see where uninitialised values come from
==1178== For lists of detected and suppressed errors, rerun with: -s
==1178== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc16
\n------------------------\n\n\n
==1181== Memcheck, a memory error detector
==1181== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1181== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1181== Command: ./testcase tc16
==1181== 
==1181== Use of uninitialised value of size 8
==1181==    at 0x10B325: create_request (server.c:419)
==1181==    by 0x10BAA5: run_test (testcase.c:73)
==1181==    by 0x10C314: url3 (testcase.c:253)
==1181==    by 0x10C9FA: main (testcase.c:429)
==1181== 
==1181== Invalid read of size 1
==1181==    at 0x10B325: create_request (server.c:419)
==1181==    by 0x10BAA5: run_test (testcase.c:73)
==1181==    by 0x10C314: url3 (testcase.c:253)
==1181==    by 0x10C9FA: main (testcase.c:429)
==1181==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==1181== 
==1181== 
==1181== Process terminating with default action of signal 11 (SIGSEGV)
==1181==  Access not within mapped region at address 0x0
==1181==    at 0x10B325: create_request (server.c:419)
==1181==    by 0x10BAA5: run_test (testcase.c:73)
==1181==    by 0x10C314: url3 (testcase.c:253)
==1181==    by 0x10C9FA: main (testcase.c:429)
==1181==  If you believe this happened as a result of a stack
==1181==  overflow in your program's main thread (unlikely but
==1181==  possible), you can try to increase the size of the
==1181==  main thread stack using the --main-stacksize= flag.
==1181==  The main thread stack size used in this run was 8388608.
==1181== 
==1181== HEAP SUMMARY:
==1181==     in use at exit: 326 bytes in 5 blocks
==1181==   total heap usage: 5 allocs, 0 frees, 326 bytes allocated
==1181== 
==1181== 4 bytes in 1 blocks are still reachable in loss record 1 of 5
==1181==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1181==    by 0x10AAFB: create_request (server.c:286)
==1181==    by 0x10BAA5: run_test (testcase.c:73)
==1181==    by 0x10C314: url3 (testcase.c:253)
==1181==    by 0x10C9FA: main (testcase.c:429)
==1181== 
==1181== 13 bytes in 1 blocks are still reachable in loss record 2 of 5
==1181==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1181==    by 0x10ADB1: create_request (server.c:342)
==1181==    by 0x10BAA5: run_test (testcase.c:73)
==1181==    by 0x10C314: url3 (testcase.c:253)
==1181==    by 0x10C9FA: main (testcase.c:429)
==1181== 
==1181== 13 bytes in 1 blocks are still reachable in loss record 3 of 5
==1181==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1181==    by 0x10ADEA: create_request (server.c:344)
==1181==    by 0x10BAA5: run_test (testcase.c:73)
==1181==    by 0x10C314: url3 (testcase.c:253)
==1181==    by 0x10C9FA: main (testcase.c:429)
==1181== 
==1181== 40 bytes in 1 blocks are still reachable in loss record 4 of 5
==1181==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1181==    by 0x10AA95: create_request (server.c:277)
==1181==    by 0x10BAA5: run_test (testcase.c:73)
==1181==    by 0x10C314: url3 (testcase.c:253)
==1181==    by 0x10C9FA: main (testcase.c:429)
==1181== 
==1181== 256 bytes in 1 blocks are still reachable in loss record 5 of 5
==1181==    at 0x484D953: calloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1181==    by 0x10BA7D: run_test (testcase.c:69)
==1181==    by 0x10C314: url3 (testcase.c:253)
==1181==    by 0x10C9FA: main (testcase.c:429)
==1181== 
==1181== LEAK SUMMARY:
==1181==    definitely lost: 0 bytes in 0 blocks
==1181==    indirectly lost: 0 bytes in 0 blocks
==1181==      possibly lost: 0 bytes in 0 blocks
==1181==    still reachable: 326 bytes in 5 blocks
==1181==         suppressed: 0 bytes in 0 blocks
==1181== 
==1181== Use --track-origins=yes to see where uninitialised values come from
==1181== For lists of detected and suppressed errors, rerun with: -s
==1181== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc17
\n------------------------\n\n\n
==1184== Memcheck, a memory error detector
==1184== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1184== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1184== Command: ./testcase tc17
==1184== 
==1184== 
==1184== HEAP SUMMARY:
==1184==     in use at exit: 0 bytes in 0 blocks
==1184==   total heap usage: 7 allocs, 7 frees, 864 bytes allocated
==1184== 
==1184== All heap blocks were freed -- no leaks are possible
==1184== 
==1184== For lists of detected and suppressed errors, rerun with: -s
==1184== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc18
\n------------------------\n\n\n
==1187== Memcheck, a memory error detector
==1187== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1187== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1187== Command: ./testcase tc18
==1187== 
==1187== 
==1187== HEAP SUMMARY:
==1187==     in use at exit: 0 bytes in 0 blocks
==1187==   total heap usage: 9 allocs, 9 frees, 1,946 bytes allocated
==1187== 
==1187== All heap blocks were freed -- no leaks are possible
==1187== 
==1187== For lists of detected and suppressed errors, rerun with: -s
==1187== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc19
\n------------------------\n\n\n
==1190== Memcheck, a memory error detector
==1190== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1190== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1190== Command: ./testcase tc19
==1190== 
==1190== 
==1190== HEAP SUMMARY:
==1190==     in use at exit: 0 bytes in 0 blocks
==1190==   total heap usage: 8 allocs, 8 frees, 1,876 bytes allocated
==1190== 
==1190== All heap blocks were freed -- no leaks are possible
==1190== 
==1190== For lists of detected and suppressed errors, rerun with: -s
==1190== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc20
\n------------------------\n\n\n
==1193== Memcheck, a memory error detector
==1193== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1193== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1193== Command: ./testcase tc20
==1193== 
==1193== 
==1193== HEAP SUMMARY:
==1193==     in use at exit: 0 bytes in 0 blocks
==1193==   total heap usage: 8 allocs, 8 frees, 1,880 bytes allocated
==1193== 
==1193== All heap blocks were freed -- no leaks are possible
==1193== 
==1193== For lists of detected and suppressed errors, rerun with: -s
==1193== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc21
\n------------------------\n\n\n
==1196== Memcheck, a memory error detector
==1196== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1196== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1196== Command: ./testcase tc21
==1196== 
==1196== Conditional jump or move depends on uninitialised value(s)
==1196==    at 0x485036C: strcmp (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1196==    by 0x10B93D: validate_request (testcase.c:41)
==1196==    by 0x10BB03: run_test (testcase.c:82)
==1196==    by 0x10C57B: kv4 (testcase.c:306)
==1196==    by 0x10C9FA: main (testcase.c:429)
==1196== 
==1196== Conditional jump or move depends on uninitialised value(s)
==1196==    at 0x4850394: strcmp (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1196==    by 0x10B93D: validate_request (testcase.c:41)
==1196==    by 0x10BB03: run_test (testcase.c:82)
==1196==    by 0x10C57B: kv4 (testcase.c:306)
==1196==    by 0x10C9FA: main (testcase.c:429)
==1196== 
==1196== Conditional jump or move depends on uninitialised value(s)
==1196==    at 0x484F229: strlen (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1196==    by 0x48CDD97: __printf_buffer (vfprintf-process-arg.c:435)
==1196==    by 0x48CE72A: __vfprintf_internal (vfprintf-internal.c:1544)
==1196==    by 0x48C31A2: printf (printf.c:33)
==1196==    by 0x10B9CE: validate_request (testcase.c:42)
==1196==    by 0x10BB03: run_test (testcase.c:82)
==1196==    by 0x10C57B: kv4 (testcase.c:306)
==1196==    by 0x10C9FA: main (testcase.c:429)
==1196== 
==1196== 
==1196== HEAP SUMMARY:
==1196==     in use at exit: 0 bytes in 0 blocks
==1196==   total heap usage: 9 allocs, 9 frees, 2,410 bytes allocated
==1196== 
==1196== All heap blocks were freed -- no leaks are possible
==1196== 
==1196== Use --track-origins=yes to see where uninitialised values come from
==1196== For lists of detected and suppressed errors, rerun with: -s
==1196== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc22
\n------------------------\n\n\n
==1199== Memcheck, a memory error detector
==1199== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1199== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1199== Command: ./testcase tc22
==1199== 
==1199== Conditional jump or move depends on uninitialised value(s)
==1199==    at 0x485036C: strcmp (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1199==    by 0x10B93D: validate_request (testcase.c:41)
==1199==    by 0x10BB03: run_test (testcase.c:82)
==1199==    by 0x10C622: kv5 (testcase.c:315)
==1199==    by 0x10C9FA: main (testcase.c:429)
==1199== 
==1199== Conditional jump or move depends on uninitialised value(s)
==1199==    at 0x4850394: strcmp (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1199==    by 0x10B93D: validate_request (testcase.c:41)
==1199==    by 0x10BB03: run_test (testcase.c:82)
==1199==    by 0x10C622: kv5 (testcase.c:315)
==1199==    by 0x10C9FA: main (testcase.c:429)
==1199== 
==1199== Conditional jump or move depends on uninitialised value(s)
==1199==    at 0x484F229: strlen (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1199==    by 0x48CDD97: __printf_buffer (vfprintf-process-arg.c:435)
==1199==    by 0x48CE72A: __vfprintf_internal (vfprintf-internal.c:1544)
==1199==    by 0x48C31A2: printf (printf.c:33)
==1199==    by 0x10B9CE: validate_request (testcase.c:42)
==1199==    by 0x10BB03: run_test (testcase.c:82)
==1199==    by 0x10C622: kv5 (testcase.c:315)
==1199==    by 0x10C9FA: main (testcase.c:429)
==1199== 
==1199== 
==1199== HEAP SUMMARY:
==1199==     in use at exit: 0 bytes in 0 blocks
==1199==   total heap usage: 10 allocs, 10 frees, 2,952 bytes allocated
==1199== 
==1199== All heap blocks were freed -- no leaks are possible
==1199== 
==1199== Use --track-origins=yes to see where uninitialised values come from
==1199== For lists of detected and suppressed errors, rerun with: -s
==1199== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc23
\n------------------------\n\n\n
==1202== Memcheck, a memory error detector
==1202== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1202== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1202== Command: ./testcase tc23
==1202== 
==1202== Conditional jump or move depends on uninitialised value(s)
==1202==    at 0x485036C: strcmp (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1202==    by 0x10B93D: validate_request (testcase.c:41)
==1202==    by 0x10BB03: run_test (testcase.c:82)
==1202==    by 0x10C6B3: kv6 (testcase.c:324)
==1202==    by 0x10C9FA: main (testcase.c:429)
==1202== 
==1202== Conditional jump or move depends on uninitialised value(s)
==1202==    at 0x4850394: strcmp (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1202==    by 0x10B93D: validate_request (testcase.c:41)
==1202==    by 0x10BB03: run_test (testcase.c:82)
==1202==    by 0x10C6B3: kv6 (testcase.c:324)
==1202==    by 0x10C9FA: main (testcase.c:429)
==1202== 
==1202== Conditional jump or move depends on uninitialised value(s)
==1202==    at 0x484F229: strlen (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1202==    by 0x48CDD97: __printf_buffer (vfprintf-process-arg.c:435)
==1202==    by 0x48CE72A: __vfprintf_internal (vfprintf-internal.c:1544)
==1202==    by 0x48C31A2: printf (printf.c:33)
==1202==    by 0x10B9CE: validate_request (testcase.c:42)
==1202==    by 0x10BB03: run_test (testcase.c:82)
==1202==    by 0x10C6B3: kv6 (testcase.c:324)
==1202==    by 0x10C9FA: main (testcase.c:429)
==1202== 
==1202== 
==1202== HEAP SUMMARY:
==1202==     in use at exit: 0 bytes in 0 blocks
==1202==   total heap usage: 9 allocs, 9 frees, 2,418 bytes allocated
==1202== 
==1202== All heap blocks were freed -- no leaks are possible
==1202== 
==1202== Use --track-origins=yes to see where uninitialised values come from
==1202== For lists of detected and suppressed errors, rerun with: -s
==1202== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc24
\n------------------------\n\n\n
==1205== Memcheck, a memory error detector
==1205== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1205== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1205== Command: ./testcase tc24
==1205== 
==1205== 
==1205== HEAP SUMMARY:
==1205==     in use at exit: 0 bytes in 0 blocks
==1205==   total heap usage: 9 allocs, 9 frees, 2,432 bytes allocated
==1205== 
==1205== All heap blocks were freed -- no leaks are possible
==1205== 
==1205== For lists of detected and suppressed errors, rerun with: -s
==1205== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc25
\n------------------------\n\n\n
==1208== Memcheck, a memory error detector
==1208== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1208== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1208== Command: ./testcase tc25
==1208== 
==1208== Conditional jump or move depends on uninitialised value(s)
==1208==    at 0x485036C: strcmp (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1208==    by 0x10B93D: validate_request (testcase.c:41)
==1208==    by 0x10BB03: run_test (testcase.c:82)
==1208==    by 0x10C7D5: kv8 (testcase.c:342)
==1208==    by 0x10C9FA: main (testcase.c:429)
==1208== 
==1208== Conditional jump or move depends on uninitialised value(s)
==1208==    at 0x4850394: strcmp (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1208==    by 0x10B93D: validate_request (testcase.c:41)
==1208==    by 0x10BB03: run_test (testcase.c:82)
==1208==    by 0x10C7D5: kv8 (testcase.c:342)
==1208==    by 0x10C9FA: main (testcase.c:429)
==1208== 
==1208== Conditional jump or move depends on uninitialised value(s)
==1208==    at 0x484F229: strlen (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==1208==    by 0x48CDD97: __printf_buffer (vfprintf-process-arg.c:435)
==1208==    by 0x48CE72A: __vfprintf_internal (vfprintf-internal.c:1544)
==1208==    by 0x48C31A2: printf (printf.c:33)
==1208==    by 0x10B9CE: validate_request (testcase.c:42)
==1208==    by 0x10BB03: run_test (testcase.c:82)
==1208==    by 0x10C7D5: kv8 (testcase.c:342)
==1208==    by 0x10C9FA: main (testcase.c:429)
==1208== 
==1208== 
==1208== HEAP SUMMARY:
==1208==     in use at exit: 0 bytes in 0 blocks
==1208==   total heap usage: 9 allocs, 9 frees, 2,410 bytes allocated
==1208== 
==1208== All heap blocks were freed -- no leaks are possible
==1208== 
==1208== Use --track-origins=yes to see where uninitialised values come from
==1208== For lists of detected and suppressed errors, rerun with: -s
==1208== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc26
\n------------------------\n\n\n
==1211== Memcheck, a memory error detector
==1211== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1211== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1211== Command: ./testcase tc26
==1211== 
==1211== 
==1211== HEAP SUMMARY:
==1211==     in use at exit: 0 bytes in 0 blocks
==1211==   total heap usage: 9 allocs, 9 frees, 2,410 bytes allocated
==1211== 
==1211== All heap blocks were freed -- no leaks are possible
==1211== 
==1211== For lists of detected and suppressed errors, rerun with: -s
==1211== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\n\n\n------------------------\n
Test case: tc27
\n------------------------\n\n\n
==1214== Memcheck, a memory error detector
==1214== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==1214== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==1214== Command: ./testcase tc27
==1214== 
==1214== 
==1214== HEAP SUMMARY:
==1214==     in use at exit: 0 bytes in 0 blocks
==1214==   total heap usage: 6 allocs, 6 frees, 324 bytes allocated
==1214== 
==1214== All heap blocks were freed -- no leaks are possible
==1214== 
==1214== For lists of detected and suppressed errors, rerun with: -s
==1214== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
